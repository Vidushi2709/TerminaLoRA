[
  {
    "instruction": "How do I undo the most recent local commits in Git?",
    "response": "Undo a commit & redo\n\n\n\n'''\n$ git commit -m \"Something terribly misguided\" # (0: Your Accident)\n$ git reset HEAD~                              # (1)\n# === If you just want to undo the commit, stop here! ===\n[ edit files as necessary ]                    # (2)\n$ git add .                                    # (3)\n$ git commit -c ORIG_HEAD                      # (4)\n'''\n\n\n\n\n\ngit reset\n is the command responsible for the \nundo\n. It will undo your last commit while \nleaving your working tree (the state of your files on disk) untouched.\n You'll need to add them again before you can commit them again.\n\n\nMake corrections to \nworking tree\n files.\n\n\ngit add\n anything that you want to include in your new commit.\n\n\nCommit the changes, reusing the old commit message. \nreset\n copied the old head to \n.git/ORIG_HEAD\n; \ncommit\n with \n-c ORIG_HEAD\n will open an editor, which initially contains the log message from the old commit and allows you to edit it. If you do not need to edit the message, you could use the \n-C\n option.\n\n\n\n\nAlternatively, to edit the previous commit (or just its commit message)\n, \ncommit --amend\n will add changes within the current index to the previous commit.\n\n\nTo remove (not revert) a commit that has been pushed to the server\n, rewriting history with \ngit push origin main --force[-with-lease]\n is necessary. \nIt's \nalmost always\n a bad idea to use \n--force\n; prefer \n--force-with-lease\n instead, and as noted in \nthe git manual\n:\n\n\n\n\nYou should understand the implications of rewriting history if you amend a commit that has already been published.\n\n\n\n\n\n\nFurther Reading\n\n\nYou can use \ngit reflog\n to determine the SHA-1\n for the commit to which you wish to revert. Once you have this value, use the sequence of commands as explained above.\n\n\n\n\nHEAD~\n is the same as \nHEAD~1\n. The article \nWhat is the HEAD in git?\n is helpful if you want to uncommit multiple commits."
  },
  {
    "instruction": "How do I delete a Git branch locally and remotely?",
    "response": "Executive Summary\n\n\n\n'''\ngit push -d <remote_name> <branchname>   # Delete remote\ngit branch -d <branchname>               # Delete local\n'''\n\n\n\nNote:\n In most cases, \n<remote_name>\n will be \norigin\n.\n\n\nDelete Local Branch\n\n\nTo delete the \nlocal\n branch, use one of the following:\n\n\n\n'''\ngit branch -d <branch_name>\ngit branch -D <branch_name>\n'''\n\n\n\n\n\nThe \n-d\n option is an alias for \n--delete\n, which only deletes the branch if it has already been fully merged in its upstream branch.\n\n\nThe \n-D\n option is an alias for \n--delete --force\n, which deletes the branch \"irrespective of its merged status.\" [Source: \nman git-branch\n]\n\n\nAs of \nGit v2.3\n, \ngit branch -d\n (delete) learned to honor the \n-f\n (force) flag.\n\n\nYou will receive an error if you try to delete the currently selected branch.\n\n\n\n\nDelete Remote Branch\n\n\nAs of \nGit v1.7.0\n, you can delete a \nremote\n branch using\n\n\n\n'''\n$ git push <remote_name> --delete <branch_name>\n'''\n\n\n\nwhich might be easier to remember than\n\n\n\n'''\n$ git push <remote_name> :<branch_name>\n'''\n\n\n\nwhich was added in \nGit v1.5.0\n \"to delete a remote branch or a tag.\"\n\n\nStarting with \nGit v2.8.0\n, you can also use \ngit push\n with the \n-d\n option as an alias for \n--delete\n. Therefore, the version of Git you have installed will dictate whether you need to use the easier or harder syntax.\n\n\nDelete Remote Branch [Original Answer from 5-Jan-2010]\n\n\nFrom Chapter 3 of \nPro Git\n by Scott Chacon:\n\n\n\n\nDeleting Remote Branches\n\n\nSuppose you’re done with a remote branch — say, you and your collaborators are finished with a feature and have merged it into your remote’s main branch (or whatever branch your stable code-line is in). You can delete a remote branch using the rather obtuse syntax \ngit push [remotename] :[branch]\n. If you want to delete your \nserverfix\n branch from the server, you run the following:\n\n\n\n'''\n$ git push origin :serverfix\nTo git@github.com:schacon/simplegit.git\n - [deleted]         serverfix\n'''\n\n\n\nBoom. No more branches on your server. You may want to dog-ear this page, because you’ll need that command, and you’ll likely forget the syntax. A way to remember this command is by recalling the \ngit push [remotename] [localbranch]:[remotebranch]\n syntax that we went over a bit earlier. If you leave off the \n[localbranch]\n portion, then you’re basically saying, “Take nothing on my side and make it be \n[remotebranch]\n.”\n\n\n\n\nI ran \ngit push origin :bugfix\n, and it worked beautifully. Scott Chacon was right—I will want to \ndog-ear\n that page (or virtually dog ear-by answering this on Stack Overflow).\n\n\nFetch changes\n\n\nFinally, execute the following on other machines to propagate changes:\n\n\n\n'''\n# Fetch changes from all remotes and locally delete \n# remote deleted branches/tags etc\n# --prune will do the job :-;\ngit fetch --all --prune\n'''"
  },
  {
    "instruction": "What is the difference between 'git pull' and 'git fetch'?",
    "response": "In the simplest terms, \ngit pull\n does a \ngit fetch\n followed by a \ngit merge\n.\n\n\n\n\ngit fetch\n updates your remote-tracking branches under \nrefs/remotes/<remote>/\n. This operation is safe to run at any time since it never changes any of your local branches under \nrefs/heads\n.\n\n\ngit pull\n brings a local branch up-to-date with its remote version, while also updating your other remote-tracking branches.\n\n\nFrom the Git documentation for \ngit pull\n:\n\n\n\n\ngit pull\n runs \ngit fetch\n with the given parameters and then depending on configuration options or command line flags, will call either \ngit rebase\n or \ngit merge\n to reconcile diverging branches."
  },
  {
    "instruction": "How can I rename a local Git branch?",
    "response": "To rename the current branch:\n\n\n\n'''\ngit branch -m <newname>\n'''\n\n\n\nTo rename a branch while pointed to any branch:\n\n\n\n'''\ngit branch -m <oldname> <newname>\n'''\n\n\n\n-m\n is short for \n--move\n.\n\n\n\n\nTo push the  local branch and reset the upstream branch:\n\n\n\n'''\ngit push origin -u <newname>\n'''\n\n\n\nTo delete the  remote branch:\n\n\n\n'''\ngit push origin --delete <oldname>\n'''\n\n\n\n\n\nTo create a \ngit rename\n alias:\n\n\n\n'''\ngit config --global alias.rename 'branch -m'\n'''\n\n\n\n\n\nOn Windows or another case-insensitive filesystem, use \n-M\n if there are only capitalization changes in the name. Otherwise, Git will throw a \n\"branch already exists\"\n error.\n\n\n\n'''\ngit branch -M <newname>\n'''"
  },
  {
    "instruction": "How do I undo 'git add' before commit?",
    "response": "To unstage a specific file\n\n\n\n'''\ngit reset <file>\n'''\n\n\n\nThat will remove the file from the current index (the \"about to be committed\" list) without changing anything else.\n\n\nTo unstage all files from the current change set:\n\n\n\n'''\ngit reset\n'''\n\n\n\n\n\nIn old versions of Git, the above commands are equivalent to \ngit reset HEAD <file>\n and \ngit reset HEAD\n respectively, and will fail if \nHEAD\n is undefined (because you haven't yet made any commits in your repository) or ambiguous (because you created a branch called \nHEAD\n, which is a stupid thing that you shouldn't do). This \nwas changed in Git 1.8.2\n, though, so in modern versions of Git you can use the commands above even prior to making your first commit:\n\n\n\n\n\"git reset\" (without options or parameters) used to error out when\nyou do not have any commits in your history, but it now gives you\nan empty index (to match non-existent commit you are not even on).\n\n\n\n\nDocumentation: \ngit reset"
  },
  {
    "instruction": "How do I force \"git pull\" to overwrite local files?",
    "response": "⚠ Warning:\n\n\nAny uncommitted local change to tracked files will be lost, \neven if staged\n.\n\n\nBut any local file that's \nnot\n tracked by Git will \nnot\n be affected.\n\n\n\n\n\n\nFirst, update all \norigin/<branch>\n refs to latest:\n\n\n\n'''\ngit fetch --all\n'''\n\n\n\nBackup your current branch (e.g. \nmain\n):\n\n\n\n'''\ngit branch backup-main\n'''\n\n\n\nJump to the latest commit on \norigin/main\n and checkout those files:\n\n\n\n'''\ngit reset --hard origin/main\n'''\n\n\n\nExplanation:\n\n\ngit fetch\n downloads the latest from remote without trying to merge or rebase anything.\n\n\ngit reset\n resets the master branch to what you just fetched. The \n--hard\n option changes all the files in your working tree to match the files in \norigin/main\n.\n\n\n\n\nMaintain current local commits\n\n\n[*]\n: It's worth noting that it is possible to maintain current local commits by creating a branch from \nmain\n before resetting:\n\n\n\n'''\ngit checkout main\ngit branch new-branch-to-save-current-commits\ngit fetch --all\ngit reset --hard origin/main\n'''\n\n\n\nAfter this, all of the old commits will be kept in \nnew-branch-to-save-current-commits\n.\n\n\nUncommitted changes\n\n\nUncommitted changes, even if staged (with \ngit add\n), will be lost. Make sure to \nstash\n or commit anything you need. For example, run the following:\n\n\n\n'''\ngit stash\n'''\n\n\n\nAnd later (after \ngit reset\n), reapply these uncommitted changes:\n\n\n\n'''\ngit stash pop\n'''\n\n\n\n\n\nWhich may create merge conflicts."
  },
  {
    "instruction": "How to check out a remote Git branch?",
    "response": "The answer has been split depending on whether there is one remote repository configured or multiple. The reason for this is that for the single remote case, some of the commands can be simplified as there is less ambiguity.\n\n\nUpdated for Git 2.23:\n For older versions, see the section at the end.\n\n\nWith One Remote\n\n\nIn both cases, start by fetching from the remote repository to make sure you have all the latest changes downloaded.\n\n\n\n'''\n$ git fetch\n'''\n\n\n\nThis will fetch all of the remote branches for you. You can see the branches available for checkout with:\n\n\n\n'''\n$ git branch -v -a\n\n...\nremotes/origin/test\n'''\n\n\n\nThe branches that start with \nremotes/*\n can be thought of as read only copies of the remote branches. To work on a branch you need to create a local branch from it. This is done with the Git command \nswitch\n (since Git 2.23) by giving it the name of the remote branch (minus the remote name):\n\n\n\n'''\n$ git switch test\n'''\n\n\n\nIn this case Git is guessing (can be disabled with \n--no-guess\n) that you are trying to checkout and track the remote branch with the same name.\n\n\nWith Multiple Remotes\n\n\nIn the case where multiple remote repositories exist, the remote repository needs to be explicitly named.\n\n\nAs before, start by fetching the latest remote changes:\n\n\n\n'''\n$ git fetch origin\n'''\n\n\n\nThis will fetch all of the remote branches for you. You can see the branches available for checkout with:\n\n\n\n'''\n$ git branch -v -a\n'''\n\n\n\nWith the remote branches in hand, you now need to check out the branch you are interested in with \n-c\n to create a new local branch:\n\n\n\n'''\n$ git switch -c test origin/test\n'''\n\n\n\nFor more information about using \ngit switch\n:\n\n\n\n'''\n$ man git-switch\n'''\n\n\n\nPrior to Git 2.23\n\n\ngit switch\n was added in Git 2.23, prior to this \ngit checkout\n was used to switch branches.\n\n\nTo checkout out with only a single remote repository:\n\n\n\n'''\ngit checkout test\n'''\n\n\n\nif there are multiple remote repositories configured then it becomes a bit longer\n\n\n\n'''\ngit checkout -b test <name of remote>/test\n'''"
  },
  {
    "instruction": "How do I make Git forget about a file that was tracked, but is now in .gitignore?",
    "response": ".gitignore\n will prevent untracked files from being added (without an \nadd -f\n) to the set of files tracked by Git. However, Git will continue to track any files that are already being tracked.\n\n\nUpdated Answer in 2024\n\n\nDo NOT use \ngit rm --cached <file>\n if you ever want to see that file again. It will remove it from git, and also your local machine.\n\n\nIf you want to keep the file locally, but remove it from git tracking, use the answer by Konstantin. In short, use the following instead of \ngit rm\n:\n\n\ngit update-index --skip-worktree <file>\n\n\nHowever, according to the official \ngit documentation\n:\n\n\n\n\nUsers often try to use the assume-unchanged and skip-worktree bits to tell Git to ignore changes to files that are tracked. This does not work as expected, since Git may still check working tree files against the index when performing certain operations. In general, Git does not provide a way to ignore changes to tracked files, so alternate solutions are recommended.\n\n\n\n\nTherefore, you should still consider using the original answer below.\n\n\nOriginal Answer\n\n\nWARNING: This will remove the physical file from your local machine and other developers' machines on your or their next \ngit pull\n.\n\n\nTo stop tracking a file, we must remove it from the index:\n\n\n\n'''\ngit rm --cached <file>\n'''\n\n\n\nTo remove a folder and all files in the folder recursively:\n\n\n\n'''\ngit rm -r --cached <folder>\n'''\n\n\n\nThe removal of the file from the head revision will happen on the next commit."
  },
  {
    "instruction": "How do I remove local (untracked) files from the current Git working tree?",
    "response": "git-clean\n - Remove untracked files from the working tree\n\n\nSynopsis\n\n\n\n'''\ngit clean [-d] [-f] [-i] [-n] [-q] [-e <pattern>] [-x | -X] [--] <path>…​\n'''\n\n\n\nDescription\n\n\nCleans the working tree by recursively removing files that are not under version control, \nstarting from the current directory\n.\n\n\nNormally, only files unknown to Git are removed, but if the \n-x\n option is specified, ignored files are also removed. This can, for example, be useful to remove all build products.\n\n\nIf any optional \n<path>...\n arguments are given, only those paths are affected.\n\n\n\n\n\n\nStep 1 is to show what will be deleted by using the \n-n\n option:\n\n\n\n'''\n# Print out the list of files and directories which will be removed (dry run)\ngit clean -n -d\n'''\n\n\n\nClean Step - \nbeware: this will delete files\n:\n\n\n\n'''\n# Delete the files from the repository\ngit clean -f\n'''\n\n\n\n\n\nTo remove directories, run \ngit clean -f -d\n or \ngit clean -fd\n\n\nTo remove ignored files, run \ngit clean -f -X\n or \ngit clean -fX\n\n\nTo remove ignored and non-ignored files, run \ngit clean -f -x\n or \ngit clean -fx\n\n\n\n\nNote\n the case difference on the \nX\n for the two latter commands.\n\n\nIf \nclean.requireForce\n is set to \"true\" (the default) in your configuration, one needs to specify \n-f\n otherwise nothing will actually happen.\n\n\nAgain see the \ngit-clean\n docs for more information.\n\n\n\n\n\n\nOptions\n\n\n-f\n, \n--force\n\n\nIf the Git configuration variable clean.requireForce is not set to\nfalse, git clean will refuse to run unless given \n-f\n, \n-n\n or \n-i\n.\n\n\n-x\n\n\nDon’t use the standard ignore rules read from .gitignore (per\ndirectory) and \n$GIT_DIR/info/exclude\n, but do still use the ignore\nrules given with \n-e\n options. This allows removing all untracked files,\nincluding build products. This can be used (possibly in conjunction\nwith git reset) to create a pristine working directory to test a clean\nbuild.\n\n\n-X\n\n\nRemove only files ignored by Git. This may be useful to rebuild\neverything from scratch, but keep manually created files.\n\n\n-n\n, \n--dry-run\n\n\nDon’t actually remove anything, just show what would be done.\n\n\n-d\n\n\nRemove untracked directories in addition to untracked files. If an\nuntracked directory is managed by a different Git repository, it is\nnot removed by default. Use \n-f\n option twice if you really want to\nremove such a directory."
  },
  {
    "instruction": "Find all files containing a specific text (string) on Linux?",
    "response": "Do the following:\n\n\n\n'''\ngrep -rnw '/path/to/somewhere/' -e 'pattern'\n'''\n\n\n\n\n\n-r\n or \n-R\n is recursive,\n\n\n-n\n is line number, and\n\n\n-w\n stands for match the whole word.\n\n\n-l\n (lower-case L) can be added to just give the file name of matching files.\n\n\n-e\n is the pattern used during the search\n\n\n\n\nAlong with these, \n--exclude\n, \n--include\n, \n--exclude-dir\n flags could be used for efficient searching:\n\n\n\n\nThis will only search through those files which have .c or .h extensions:\n\n\n\n'''\ngrep --include=\\*.{c,h} -rnw '/path/to/somewhere/' -e \"pattern\"\n'''\n\n\n\n\n\nThis will exclude searching all the files ending with .o extension:\n\n\n\n'''\ngrep --exclude=\\*.o -rnw '/path/to/somewhere/' -e \"pattern\"\n'''\n\n\n\n\n\nFor directories it's possible to exclude one or more directories using the \n--exclude-dir\n parameter. For example, this will exclude the dirs \ndir1/\n, \ndir2/\n and all of them matching \n*.dst/\n:\n\n\n\n'''\ngrep --exclude-dir={dir1,dir2,*.dst} -rnw '/path/to/search/' -e \"pattern\"\n'''\n\n\n\n\n\n\n\nThis works very well for me, to achieve almost the same purpose like yours.\n\n\nFor more options, see \nman grep\n."
  },
  {
    "instruction": "How to modify existing, unpushed commit messages?",
    "response": "Amending the most recent commit message\n\n\n\n'''\ngit commit --amend\n'''\n\n\n\nwill open your editor, allowing you to change the commit message of the most recent commit. Additionally, you can set the commit message directly in the command line with:\n\n\n\n'''\ngit commit --amend -m \"New commit message\"\n'''\n\n\n\n…however, this can make multi-line commit messages or small corrections more cumbersome to enter.\n\n\nMake sure you don't have any working copy changes \nstaged\n before doing this or they will get committed too. (\nUnstaged\n changes will not get committed.)\n\n\nChanging the message of a commit that you've already pushed to your remote branch\n\n\nIf you've already pushed your commit up to your remote branch, then - after amending your commit locally (as described above) - you'll also \nneed to force push the commit\n with:\n\n\n\n'''\ngit push <remote> <branch> --force\n# Or\ngit push <remote> <branch> -f\n'''\n\n\n\nWarning: force-pushing will overwrite the remote branch with the state of your local one\n. If there are commits on the remote branch that you don't have in your local branch, you \nwill\n lose those commits.\n\n\nWarning: be cautious about amending commits that you have already shared with other people.\n Amending commits essentially \nrewrites\n them to have different \nSHA\n IDs, which poses a problem if other people have copies of the old commit that you've rewritten. Anyone who has a copy of the old commit will need to synchronize their work with your newly re-written commit, which can sometimes be difficult, so make sure you coordinate with others when attempting to rewrite shared commit history, or just avoid rewriting shared commits altogether.\n\n\n\n\nPerform an interactive rebase\n\n\nAnother option is to use interactive rebase.\nThis allows you to edit any message you want to update even if it's not the latest message.\n\n\nIn order to do a Git squash, follow these steps:\n\n\n\n'''\n// n is the number of commits up to the last commit you want to be able to edit\ngit rebase -i HEAD~n\n'''\n\n\n\nOnce you squash your commits - choose the \ne/r\n for editing the message:\n\n\n\n\nImportant note about interactive rebase\n\n\nWhen you use \ngit rebase -i HEAD~n\n there can be \nmore\n than n commits. Git will \"collect\" all the commits in the last n commits, and if there was a merge somewhere in between that range you will see all the commits as well, so the outcome will be n + .\n\n\nGood tip:\n\n\nIf you have to do it for more than a single branch and you might face conflicts when amending the content, set up \ngit rerere\n and let Git resolve those conflicts automatically for you.\n\n\n\n\nDocumentation\n\n\n\n\ngit-commit(1) Manual Page\n\n\n\n\ngit-rebase(1) Manual Page\n\n\n\n\ngit-push(1) Manual Page"
  },
  {
    "instruction": "How do I revert a Git repository to a previous commit?",
    "response": "This depends a lot on what you mean by \"revert\".\n\n\nTemporarily switch to a different commit\n\n\nIf you want to temporarily go back to it, fool around, then come back to where you are, all you have to do is check out the desired commit:\n\n\n\n'''\n# This will detach your HEAD, that is, leave you with no branch checked out:\ngit checkout 0d1d7fc32\n'''\n\n\n\nOr if you want to make commits while you're there, go ahead and make a new branch while you're at it:\n\n\n\n'''\ngit checkout -b old-state 0d1d7fc32\n'''\n\n\n\nTo go back to where you were, just check out the branch you were on again. (If you've made changes, as always when switching branches, you'll have to deal with them as appropriate. You could reset to throw them away; you could stash, checkout, stash pop to take them with you; you could commit them to a branch there if you want a branch there.)\n\n\nHard delete unpublished commits\n\n\nIf, on the other hand, you want to really get rid of everything you've done since then, there are two possibilities. One, if you haven't published any of these commits, simply reset:\n\n\n\n'''\n# This will destroy any local modifications.\n# Don't do it if you have uncommitted work you want to keep.\ngit reset --hard 0d1d7fc32\n\n# Alternatively, if there's work to keep:\ngit stash\ngit reset --hard 0d1d7fc32\ngit stash pop\n# This saves the modifications, then reapplies that patch after resetting.\n# You could get merge conflicts, if you've modified things which were\n# changed since the commit you reset to.\n'''\n\n\n\nIf you mess up, you've already thrown away your local changes, but you can at least get back to where you were before by resetting again.\n\n\nUndo published commits with new commits\n\n\nOn the other hand, if you've published the work, you probably don't want to reset the branch, since that's effectively rewriting history. In that case, you could indeed revert the commits. In many enterprise organisations, the concept of \"protected\" branches will even prevent history from being rewritten on some major branches. In this case, reverting is your only option.\n\n\nWith Git, revert has a very specific meaning: create a commit with the reverse patch to cancel it out. This way you don't rewrite any history.\n\n\nFirst figure out what commits to revert. Depending on the technique chosen below, you want to either revert only the merge commits, or only the non-merge commits.\n\n\n\n'''\n# This lists all merge commits between 0d1d7fc and HEAD:\ngit log --merges --pretty=format:\"%h\" 0d1d7fc..HEAD | tr '\\n' ' '\n\n# This lists all non merge commits between 0d1d7fc and HEAD:\ngit log --no-merges --pretty=format:\"%h\" 0d1d7fc..HEAD | tr '\\n' ' '\n'''\n\n\n\nNote: if you revert multiple commits, the order matters. Start with the most recent commit.\n\n\n\n'''\n# This will create three separate revert commits, use non merge commits only:\ngit revert a867b4af 25eee4ca 0766c053\n\n# It also takes ranges. This will revert the last two commits:\ngit revert HEAD~2..HEAD\n\n# Similarly, you can revert a range of commits using commit hashes (non inclusive of first hash):\ngit revert 0d1d7fc..a867b4a\n\n# Reverting a merge commit. You can also use a range of merge commits here.\ngit revert -m 1 <merge_commit_sha>\n\n# To get just one, you could use `rebase -i` to squash them afterwards\n# Or, you could do it manually (be sure to do this at top level of the repo)\n# get your index and work tree into the desired state, without changing HEAD:\ngit checkout 0d1d7fc32 .\n\n# Then commit. Be sure and write a good message describing what you just did\ngit commit\n'''\n\n\n\nThe \ngit-revert\n manpage\n actually covers a lot of this in its description. Another useful link is \nthis git-scm.com section discussing git-revert\n.\n\n\nIf you decide you didn't want to revert after all, you can revert the revert (as described here) or reset back to before the revert (see the previous section).\n\n\nYou may also find this answer helpful in this case:\n\n\nHow can I move HEAD back to a previous location? (Detached head) & Undo commits"
  },
  {
    "instruction": "How do I change the URI (URL) for a remote Git repository?",
    "response": "First, view the existing remotes to verify which URL is currently set:\n\n\n\n'''\ngit remote -v\n'''\n\n\n\nThen, you can set it with:\n\n\n\n'''\ngit remote set-url origin <NEW_GIT_URL_HERE>\n'''\n\n\n\nSee \ngit help remote\n. You also can edit \n.git/config\n and change the URLs there.\n\n\nYou're not in any danger of losing history unless you do something very silly (and if you're worried, just make a copy of your repo, since your repo \nis\n your history.)"
  },
  {
    "instruction": "Move the most recent commit(s) to a new branch with Git",
    "response": "WARNING: You \nneed to store uncommitted edits\n to your stash before doing this, using \ngit stash\n. Once complete, you can retrieve the stashed uncommitted edits with \ngit stash pop\n. \ngit reset hard command will remove all changes!\n\n\nMoving to an existing branch\n\n\nIf you want to move your commits to an \nexisting branch\n, it will look like this:\n\n\n\n'''\ngit checkout existingbranch\ngit merge branchToMoveCommitFrom\ngit checkout branchToMoveCommitFrom\ngit reset --hard HEAD~3 # Go back 3 commits. You *will* lose uncommitted work.\ngit checkout existingbranch\n'''\n\n\n\nMoving to a new branch\n\n\nWARNING:\n This method works because you are creating a new branch with the first command: \ngit branch newbranch\n. If you want to move commits to an \nexisting branch\n you need to merge your changes into the existing branch before executing \ngit reset --hard HEAD~3\n (see \nMoving to an existing branch\n above). \nIf you don't merge your changes first, they will be lost.\n\n\nUnless there are other circumstances involved, this can be easily done by branching and rolling back.\n\n\n\n'''\n# Note: Any changes not committed will be lost.\ngit branch newbranch      # Create a new branch, saving the desired commits\ngit checkout master       # checkout master, this is the place you want to go back\ngit reset --hard HEAD~3   # Move master back by 3 commits (Make sure you know how many commits you need to go back)\ngit checkout newbranch    # Go to the new branch that still has the desired commits\n'''\n\n\n\nBut do make sure how many commits to go back. Alternatively, you can instead of \nHEAD~3\n, simply provide the hash of the commit (or the reference like \norigin/master\n) you want to \"revert back to\" on the \nmaster\n (/current) branch, e.g:\n\n\n\n'''\ngit reset --hard a1b2c3d4\n'''\n\n\n\nNote:\n You will \nonly\n be \"losing\" commits from the master branch, but don't worry, you'll have those commits in newbranch! An easy way to check that, after completing the 4 step sequence of commands above, is by looking at \ngit log -n4\n which will show the history of newbranch actually retained the 3 commits (and the reason is that newbranch was created at the time those changes were already commited on master!). They have only been removed from master, as \ngit reset\n only affected the branch that was checked out at the time of its execution, i.e. master (see \ngit reset\n description: \nReset \ncurrent\n HEAD to the specified state\n). \ngit status\n however will not show any checkouts on the newbranch, which might be surprising at first but that is actually expected.\n\n\nLastly, \nyou may need\n to force push your latest changes to main repo:\n\n\n\n'''\ngit push origin master --force\n'''\n\n\n\nWARNING:\n With Git version 2.0 and later, if you later \ngit rebase\n the new branch upon the original (\nmaster\n) branch, you may need an explicit \n--no-fork-point\n option during the rebase to avoid losing the carried-over commits.  Having \nbranch.autosetuprebase always\n set makes this more likely.  See \nJohn Mellor's answer\n for details."
  },
  {
    "instruction": "How do I discard unstaged changes in Git?",
    "response": "Another quicker way is:\n\n\n\n'''\ngit stash save --keep-index --include-untracked\n'''\n\n\n\nYou don't need to include \n--include-untracked\n if you don't want to be thorough about it.\n\n\nAfter that, you can drop that stash with a \ngit stash drop\n command if you like."
  },
  {
    "instruction": "How do I get the directory where a Bash script is located from within the script itself?",
    "response": "'''\n#!/usr/bin/env bash\n\nSCRIPT_DIR=$( cd -- \"$( dirname -- \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )\n'''\n\n\n\nis a useful one-liner which will give you the full directory name of the script no matter where it is being called from.\n\n\nIt will work as long as the last component of the path used to find the script is not a symlink (directory links are OK).  If you also want to resolve any links to the script itself, you need a multi-line solution:\n\n\n\n'''\n#!/usr/bin/env bash\n\nget_script_dir()\n{\n    local SOURCE_PATH=\"${BASH_SOURCE[0]}\"\n    local SYMLINK_DIR\n    local SCRIPT_DIR\n    # Resolve symlinks recursively\n    while [ -L \"$SOURCE_PATH\" ]; do\n        # Get symlink directory\n        SYMLINK_DIR=\"$( cd -P \"$( dirname \"$SOURCE_PATH\" )\" >/dev/null 2>&1 && pwd )\"\n        # Resolve symlink target (relative or absolute)\n        SOURCE_PATH=\"$(readlink \"$SOURCE_PATH\")\"\n        # Check if candidate path is relative or absolute\n        if [[ $SOURCE_PATH != /* ]]; then\n            # Candidate path is relative, resolve to full path\n            SOURCE_PATH=$SYMLINK_DIR/$SOURCE_PATH\n        fi\n    done\n    # Get final script directory path from fully resolved source path\n    SCRIPT_DIR=\"$(cd -P \"$( dirname \"$SOURCE_PATH\" )\" >/dev/null 2>&1 && pwd)\"\n    echo \"$SCRIPT_DIR\"\n}\n\necho \"get_script_dir: $(get_script_dir)\"\n'''\n\n\n\nThis last one will work with any combination of aliases, \nsource\n, \nbash -c\n, symlinks, etc.\n\n\nBeware:\n if you \ncd\n to a different directory before running this snippet, the result may be incorrect!\n\n\nAlso, watch out for \n$CDPATH\n gotchas\n, and stderr output side effects if the user has smartly overridden cd to redirect output to stderr instead (including escape sequences, such as when calling \nupdate_terminal_cwd >&2\n on Mac). Adding \n>/dev/null 2>&1\n at the end of your \ncd\n command will take care of both possibilities.\n\n\nTo understand how it works, try running this more verbose form:\n\n\n\n'''\n#!/usr/bin/env bash\n\nSOURCE=${BASH_SOURCE[0]}\nwhile [ -L \"$SOURCE\" ]; do # resolve $SOURCE until the file is no longer a symlink\n  TARGET=$(readlink \"$SOURCE\")\n  if [[ $TARGET == /* ]]; then\n    echo \"SOURCE '$SOURCE' is an absolute symlink to '$TARGET'\"\n    SOURCE=$TARGET\n  else\n    DIR=$( dirname \"$SOURCE\" )\n    echo \"SOURCE '$SOURCE' is a relative symlink to '$TARGET' (relative to '$DIR')\"\n    SOURCE=$DIR/$TARGET # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located\n  fi\ndone\necho \"SOURCE is '$SOURCE'\"\nRDIR=$( dirname \"$SOURCE\" )\nDIR=$( cd -P \"$( dirname \"$SOURCE\" )\" >/dev/null 2>&1 && pwd )\nif [ \"$DIR\" != \"$RDIR\" ]; then\n  echo \"DIR '$RDIR' resolves to '$DIR'\"\nfi\necho \"DIR is '$DIR'\"\n'''\n\n\n\nAnd it will print something like:\n\n\n\n'''\nSOURCE './scriptdir.sh' is a relative symlink to 'sym2/scriptdir.sh' (relative to '.')\nSOURCE is './sym2/scriptdir.sh'\nDIR './sym2' resolves to '/home/ubuntu/dotfiles/fo fo/real/real1/real2'\nDIR is '/home/ubuntu/dotfiles/fo fo/real/real1/real2'\n'''"
  },
  {
    "instruction": "Reset local repository branch to be just like remote repository HEAD",
    "response": "Setting your branch to exactly match the remote branch can be done in two steps:\n\n\n\n'''\ngit fetch origin\ngit reset --hard origin/master\n'''\n\n\n\nIf your default branch is \nmain\n (GitHub changed the default branch name from \nmaster\n to \nmain\n \nstarting October 1, 2020\n):\n\n\n\n'''\ngit reset --hard origin/main\n'''\n\n\n\nIf you want to save your current branch's state before doing this (just in case), you can do:\n\n\n\n'''\ngit commit -a -m \"Saving my work, just in case\"\ngit branch my-saved-work\n'''\n\n\n\nNow your work is saved on the branch \"my-saved-work\" in case you decide you want it back (or want to look at it later or diff it against your updated branch).\n\n\nNote that the first example assumes that the remote repo's name is \"origin\" and that the branch named \"master\" in the remote repo matches the currently checked-out branch in your local repo.\n\n\nBTW, this situation that you're in looks an awful lot like a common case where a push has been done into the currently checked out branch of a non-bare repository. Did you recently push into your local repo? If not, then no worries -- something else must have caused these files to unexpectedly end up modified. Otherwise, you should be aware that it's not recommended to push into a non-bare repository (and not into the currently checked-out branch, in particular)."
  },
  {
    "instruction": "How can I reset or revert a file to a specific revision?",
    "response": "Assuming the hash of the commit you want is \nc5f567\n:\n\n\n\n'''\ngit checkout c5f567 -- file1/to/restore file2/to/restore\n'''\n\n\n\nThe \ngit checkout\n man page gives more information.\n\n\nIf you want to revert to the commit before \nc5f567\n, append \n~1\n (where 1 is the number of commits you want to go back, it can be anything):\n\n\n\n'''\ngit checkout c5f567~1 -- file1/to/restore file2/to/restore\n'''\n\n\n\nAs a side note, I've always been uncomfortable with this command because it's used for both ordinary things (changing between branches) and unusual, destructive things (discarding changes in the working directory).\n\n\nFor the meaning of \n--\n in the command, refer to \nIn Git, what does \n--\n (dash dash) mean?\n\n\n\n\nThere is also a new \ngit restore\n command that is specifically designed for restoring working copy files that have been modified. If your git is new enough you can use this command, but the documentation comes with a warning:\n\n\n\n\nTHIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE.\n\n\n\n\nBecause \ngit restore\n is experimental, it should not yet be promoted as the primary answer to this question. When the command is no longer marked as \"experimental\", then this answer can be amended to promote the use of \ngit restore\n. [At the time of writing, the \ngit restore\n command has been marked as \"experimental\" for at least four years.]"
  },
  {
    "instruction": "How do I push a new local branch to a remote Git repository and track it too?",
    "response": "In Git 1.7.0 and later, you can checkout a new branch:\n\n\n\n'''\ngit checkout -b <branch>\n'''\n\n\n\nEdit files, add and commit. Then \npush with the \n-u\n (short for \n--set-upstream\n)\n option:\n\n\n\n'''\ngit push -u origin <branch>\n'''\n\n\n\nGit will set up the tracking information during the push."
  },
  {
    "instruction": "How do I squash my last N commits together?",
    "response": "Use \ngit rebase -i <after-this-commit>\n and replace \"pick\" on the second and subsequent commits with \"squash\" or \"fixup\", as described in \nthe manual\n.\n\n\nIn this example, \n<after-this-commit>\n is either the SHA1 hash or the relative location from the HEAD of the current branch from which commits are analyzed for the rebase command. For example, if the user wishes to view 5 commits from the current HEAD in the past, the command is \ngit rebase -i HEAD~5\n."
  },
  {
    "instruction": "How to determine the URL that a local Git repository was originally cloned from",
    "response": "To obtain only the remote URL:\n\n\n\n'''\ngit config --get remote.origin.url\n'''\n\n\n\nIf you require full output, and you are on a network that can reach the remote repo where the origin resides:\n\n\n\n'''\ngit remote show origin\n'''\n\n\n\nWhen using \ngit clone\n (from GitHub, or any source repository for that matter) the default name for the source of the clone is \"origin\". Using \ngit remote show\n will display the information about this remote name. The first few lines should show:\n\n\n\n'''\nC:\\Users\\jaredpar\\VsVim> git remote show origin\n* remote origin\n  Fetch URL: git@github.com:jaredpar/VsVim.git\n  Push  URL: git@github.com:jaredpar/VsVim.git\n  HEAD branch: master\n  Remote branches:\n'''\n\n\n\nIf you want to use the value in a script, you would use the first command listed in this answer."
  },
  {
    "instruction": "How do I add an empty directory to a Git repository?",
    "response": "Another way to make a directory stay (almost) empty (in the repository) is to create a \n.gitignore\n file inside that directory that contains these four lines:\n\n\n\n'''\n# Ignore everything in this directory\n*\n# Except this file\n!.gitignore\n'''\n\n\n\nThen you don't have to get the order right the way that you have to do in m104's \nsolution\n.\n\n\nThis also gives the benefit that files in that directory won't show up as \"untracked\" when you do a git status.\n\n\nMaking \n@GreenAsJade\n's comment persistent:\n\n\n\n\nI think it's worth noting that this solution does precisely what the question asked for, but is not perhaps what many people looking at this question will have been looking for. This solution guarantees that the directory remains empty. It says \"I truly never want files checked in here\". As opposed to \"I don't have any files to check in here, yet, but I need the directory here, files may be coming later\"."
  },
  {
    "instruction": "How do I resolve merge conflicts in a Git repository?",
    "response": "Try:\n\n\n\n'''\ngit mergetool\n'''\n\n\n\nIt opens a GUI that steps you through each conflict, and you get to choose how to merge.  Sometimes it requires a bit of hand editing afterwards, but usually it's enough by itself.  It is much better than doing the whole thing by hand certainly.\n\n\n\n\nAs per \nJosh Glover's comment\n:\n\n\n\n\n[This command]\ndoesn't necessarily open a GUI unless you install one. Running \ngit mergetool\n for me resulted in \nvimdiff\n being used. You can install\none of the following tools to use it instead: \nmeld\n, \nopendiff\n,\n\nkdiff3\n, \ntkdiff\n, \nxxdiff\n, \ntortoisemerge\n, \ngvimdiff\n, \ndiffuse\n,\n\necmerge\n, \np4merge\n, \naraxis\n, \nvimdiff\n, \nemerge\n.\n\n\n\n\n\n\nBelow is a sample procedure using \nvimdiff\n to resolve merge conflicts, based on \nthis link\n.\n\n\n\n\nRun the following commands in your terminal\n\n\n\n'''\ngit config merge.tool vimdiff\ngit config merge.conflictstyle diff3\ngit config mergetool.prompt false\n'''\n\n\n\nThis will set \nvimdiff\n as the default merge tool.\n\n\n\n\nRun the following command in your terminal\n\n\n\n'''\ngit mergetool\n'''\n\n\n\n\n\nYou will see a \nvimdiff\n display in the following format:\n\n\n\n'''\n╔═══════╦══════╦════════╗\n  ║       ║      ║        ║\n  ║ LOCAL ║ BASE ║ REMOTE ║\n  ║       ║      ║        ║\n  ╠═══════╩══════╩════════╣\n  ║                       ║\n  ║        MERGED         ║\n  ║                       ║\n  ╚═══════════════════════╝\n'''\n\n\n\nThese 4 views are\n\n\n\n\nLOCAL:\n this is the file from the current branch\n\n\nBASE:\n the common ancestor, how this file looked before both changes\n\n\nREMOTE:\n the file you are merging into your branch\n\n\nMERGED:\n the merge result; this is what gets saved in the merge commit and used in the future\n\n\n\n\nYou can navigate among these views using \nctrl\n+\nw\n. You can directly reach the MERGED view using \nctrl\n+\nw\n followed by \nj\n.\n\n\nMore information about \nvimdiff\n navigation is \nhere\n and \nhere\n.\n\n\n\n\nYou can edit the MERGED view like this:\n\n\n\n\nIf you want to get changes from REMOTE\n\n\n\n'''\n:diffg RE\n'''\n\n\n\n\n\nIf you want to get changes from BASE\n\n\n\n'''\n:diffg BA\n'''\n\n\n\n\n\nIf you want to get changes from LOCAL\n\n\n\n'''\n:diffg LO\n'''\n\n\n\n\n\n\n\n\n\nSave, Exit, Commit, and Clean up\n\n\n:wqa\n save and exit from vi\n\n\ngit commit -m \"message\"\n\n\ngit clean\n Remove extra files (e.g. \n*.orig\n). \nWarning:\n It will remove all untracked files, if you won't pass any arguments."
  },
  {
    "instruction": "How can I delete a remote tag?",
    "response": "You can push an 'empty' reference to the remote tag name:\n\n\n\n'''\ngit push origin :tagname\n'''\n\n\n\nOr, more expressively, use the \n--delete\n option (or \n-d\n if your git version is older than 1.8.0):\n\n\n\n'''\ngit push --delete origin tagname\n'''\n\n\n\nNote that git has tag namespace and branch namespace so you may use the same name for a branch and for a tag. If you want to make sure that you cannot accidentally remove the branch instead of the tag, you can specify full ref which will never delete a branch:\n\n\n\n'''\ngit push origin :refs/tags/tagname\n'''\n\n\n\nIf you also need to delete the local tag, use:\n\n\n\n'''\ngit tag --delete tagname\n'''\n\n\n\nor\n\n\n\n'''\ngit tag -d tagname\n'''\n\n\n\n\n\nBackground\n\n\nPushing a branch, tag, or other ref to a remote repository involves specifying \"which repo, what source, what destination?\"\n\n\n\n'''\ngit push remote-repo source-ref:destination-ref\n'''\n\n\n\nA real world example where you push your master branch to the origin's master branch is:\n\n\n\n'''\ngit push origin refs/heads/master:refs/heads/master\n'''\n\n\n\nWhich because of default paths, can be shortened to:\n\n\n\n'''\ngit push origin master:master\n'''\n\n\n\nTags work the same way:\n\n\n\n'''\ngit push origin refs/tags/release-1.0:refs/tags/release-1.0\n'''\n\n\n\nWhich can also be shortened to:\n\n\n\n'''\ngit push origin release-1.0:release-1.0\n'''\n\n\n\nBy omitting the source ref (the part before the colon), you push 'nothing' to the destination, deleting the ref on the remote end."
  },
  {
    "instruction": "Undo a Git merge that hasn't been pushed yet",
    "response": "With \ngit reflog\n check which commit is one prior the merge (\ngit reflog\n will be a better option than \ngit log\n). Then you can reset it using:\n\n\n\n'''\ngit reset --hard commit_sha\n'''\n\n\n\nThere's also another way:\n\n\n\n'''\ngit reset --hard HEAD~1\n'''\n\n\n\nIt will get you back 1 commit.\n\n\nBe aware that any modified and uncommitted/unstashed files will be reset to their unmodified state\n. To keep them either stash changes away or see \n--merge\n option below.  \n\n\n\n\nAs @Velmont suggested below in his answer, in this direct case using:\n\n\n\n'''\ngit reset --hard ORIG_HEAD\n'''\n\n\n\nmight yield better results, as it should preserve your changes. \nORIG_HEAD\n will point to a commit directly before merge has occurred, so you don't have to hunt for it yourself.\n\n\n\n\nA further tip is to use the \n--merge\n switch instead of \n--hard\n since it doesn't reset files unnecessarily:\n\n\n\n'''\ngit reset --merge ORIG_HEAD\n'''\n\n\n\n\n\n--merge\n\n\nResets the index and updates the files in the working tree that are different between <commit> and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added)."
  },
  {
    "instruction": "How do I clone all remote branches?",
    "response": "First, clone a remote \nGit\n repository and \ncd\n into it:\n\n\n\n'''\n$ git clone git://example.com/myproject\n$ cd myproject\n'''\n\n\n\nNext, look at the local branches in your repository:\n\n\n\n'''\n$ git branch\n* master\n'''\n\n\n\nBut there are other branches hiding in your repository! See these using the \n-a\n flag:\n\n\n\n'''\n$ git branch -a\n* master\n  remotes/origin/HEAD\n  remotes/origin/master\n  remotes/origin/v1.0-stable\n  remotes/origin/experimental\n'''\n\n\n\nTo take a quick peek at an upstream branch, check it out directly:\n\n\n\n'''\n$ git checkout origin/experimental\n'''\n\n\n\nTo work on that branch, create a local tracking branch, which is done automatically by:\n\n\n\n'''\n$ git checkout experimental\n\nBranch experimental set up to track remote branch experimental from origin.\nSwitched to a new branch 'experimental'\n'''\n\n\n\nHere, \"new branch\" simply means that the branch is taken from the index and created locally for you.  As the \nprevious\n line tells you, the branch is being set up to track the remote branch, which usually means the origin/branch_name branch.\n\n\nYour local branches should now show:\n\n\n\n'''\n$ git branch\n* experimental\n  master\n'''\n\n\n\nYou can track more than one remote repository using \ngit remote\n:\n\n\n\n'''\n$ git remote add win32 git://example.com/users/joe/myproject-win32-port\n$ git branch -a\n* master\n  remotes/origin/HEAD\n  remotes/origin/master\n  remotes/origin/v1.0-stable\n  remotes/origin/experimental\n  remotes/win32/master\n  remotes/win32/new-widgets\n'''\n\n\n\nAt this point, things are getting pretty crazy, so run \ngitk\n to see what's going on:\n\n\n\n'''\n$ gitk --all &\n'''"
  },
  {
    "instruction": "How do I update or sync a forked repository on GitHub?",
    "response": "In your local clone of your forked repository, you can add the original GitHub repository as a \"remote\".  (\"Remotes\" are like nicknames for the URLs of repositories - \norigin\n is one, for example.)  Then you can fetch all the branches from that upstream repository, and rebase your work to continue working on the upstream version.  In terms of commands that might look like:\n\n\n\n'''\n# Add the remote, call it \"upstream\":\n\ngit remote add upstream https://github.com/whoever/whatever.git\n\n# Fetch all the branches of that remote into remote-tracking branches\n\ngit fetch upstream\n\n# Make sure that you're on your main branch:\n\ngit checkout main\n\n# Rewrite your main branch so that any commits of yours that\n# aren't already in upstream/main are replayed on top of that\n# other branch:\n\ngit rebase upstream/main\n'''\n\n\n\nIf you don't want to rewrite the history of your main branch, (for example because other people may have cloned it) then you should replace the last command with \ngit merge upstream/main\n.  However, for making further pull requests that are as clean as possible, it's probably better to rebase.\n\n\n\n\nIf you've rebased your branch onto \nupstream/main\n you may need to force the push in order to push it to your own forked repository on GitHub.  You'd do that with:\n\n\n\n'''\ngit push -f origin main\n'''\n\n\n\nYou only need to use the \n-f\n the first time after you've rebased."
  },
  {
    "instruction": "How do I remove a submodule?",
    "response": "Since \ngit1.8.3 (April 22d, 2013)\n:\n\n\n\n\nThere was no Porcelain way to say \"I no longer am interested in this submodule\", once you express your interest in a submodule with \"\ngit submodule init\n\".\n\n\"\ngit submodule deinit\n\" is the way to do so.\n\n\n\n\nThe deletion process also uses \ngit rm\n (since git1.8.5 October 2013).\n\n\nSummary\n\n\nThe 3-steps removal process would then be:\n\n\n\n'''\n0. mv a/submodule a/submodule_tmp\n\n1. git submodule deinit -f -- a/submodule    \n2. rm -rf .git/modules/a/submodule\n3. git rm -f a/submodule\n# Note: a/submodule (no trailing slash)\n\n# or, if you want to leave it in your working tree and have done step 0\n3.   git rm --cached a/submodule\n3bis mv a/submodule_tmp a/submodule\n'''\n\n\n\nExplanation\n\n\nrm -rf\n: This is mentioned in \nDaniel Schroeder\n's \nanswer\n, and summarized by \nEonil\n in \nthe comments\n:\n\n\n\n\nThis leaves \n.git/modules/<path-to-submodule>/\n unchanged.\n\nSo if you once delete a submodule with this method and re-add them again, it will not be possible because repository already been corrupted.\n\n\n\n\n\n\ngit rm\n: See \ncommit 95c16418\n:\n\n\n\n\nCurrently using \"\ngit rm\n\" on a submodule removes the submodule's work tree from that of the superproject and the gitlink from the index.\n\nBut the submodule's section in \n.gitmodules\n is left untouched, which is a leftover of the now removed submodule and might irritate users (as opposed to the setting in \n.git/config\n, this must stay as a reminder that the user showed interest in this submodule so it will be repopulated later when an older commit is checked out).\n\n\n\n\n\n\nLet \"\ngit rm\n\" help the user by not only removing the submodule from the work tree but by also removing the \"\nsubmodule.<submodule name>\n\" section from the \n.gitmodules\n file and stage both.\n\n\n\n\n\n\ngit submodule deinit\n: It stems from \nthis patch\n:\n\n\n\n\nWith \"\ngit submodule init\n\" the user is able to tell git they care about one or more submodules and wants to have it populated on the next call to \"\ngit submodule update\n\".\n\nBut currently there is no easy way they can tell git they do not care about a submodule anymore and wants to get rid of the local work tree (unless the user knows a lot about submodule internals and removes the \"\nsubmodule.$name.url\n\" setting from \n.git/config\n together with the work tree himself).\n\n\n\n\n\n\nHelp those users by providing a '\ndeinit\n' command.\n\nThis \nremoves the whole \nsubmodule.<name>\n section from \n.git/config\n either for the given\nsubmodule(s)\n (or for all those which have been initialized if '\n.\n' is given).\n\nFail if the current work tree contains modifications unless forced.\n\nComplain when for a submodule given on the command line the url setting can't be found in \n.git/config\n, but nonetheless don't fail.\n\n\n\n\nThis takes care if the (de)initialization steps (\n.git/config\n and \n.git/modules/xxx\n)\n\n\nSince git1.8.5, the \ngit rm\n takes \nalso\n care of the:\n\n\n\n\n'\nadd\n' step which records the url of a submodule in the \n.gitmodules\n file: it is need to removed for you.\n\n\nthe submodule \nspecial entry\n (as illustrated by \nthis question\n): the git rm removes it from the index:\n\n\ngit rm --cached path_to_submodule\n (no trailing slash)\n\nThat will remove that directory stored in the index with a special mode \"160000\", marking it as a submodule root directory.\n\n\n\n\nIf you forget that last step, and try to add what was a submodule as a regular directory, you would get error message like:\n\n\n\n'''\ngit add mysubmodule/file.txt \nPath 'mysubmodule/file.txt' is in submodule 'mysubmodule'\n'''\n\n\n\n\n\nNote: since Git 2.17 (Q2 2018), git submodule deinit is no longer a shell script.\n\nIt is a call to a C function.\n\n\nSee \ncommit 2e61273\n, \ncommit 1342476\n (14 Jan 2018) by \nPrathamesh Chavan (\npratham-pc\n)\n.\n\n\n(Merged by \nJunio C Hamano -- \ngitster\n --\n in \ncommit ead8dbe\n, 13 Feb 2018)\n\n\n\n'''\ngit ${wt_prefix:+-C \"$wt_prefix\"} submodule--helper deinit \\\n  ${GIT_QUIET:+--quiet} \\\n  ${prefix:+--prefix \"$prefix\"} \\\n  ${force:+--force} \\\n  ${deinit_all:+--all} \"$@\"\n'''"
  },
  {
    "instruction": "How do I check if a directory exists or not in a Bash shell script?",
    "response": "To check if a directory exists:\n\n\n\n'''\nif [ -d \"$DIRECTORY\" ]; then\n  echo \"$DIRECTORY does exist.\"\nfi\n'''\n\n\n\nTo check if a directory does not exist:\n\n\n\n'''\nif [ ! -d \"$DIRECTORY\" ]; then\n  echo \"$DIRECTORY does not exist.\"\nfi\n'''\n\n\n\n\n\nHowever, as \nJon Ericson\n points out, subsequent commands may not work as intended if you do not take into account that a symbolic link to a directory will also pass this check.\nE.g. running this:\n\n\n\n'''\nln -s \"$ACTUAL_DIR\" \"$SYMLINK\"\nif [ -d \"$SYMLINK\" ]; then \n  rmdir \"$SYMLINK\" \nfi\n'''\n\n\n\nWill produce the error message:\n\n\n\n'''\nrmdir: failed to remove `symlink': Not a directory\n'''\n\n\n\nSo symbolic links may have to be treated differently, if subsequent commands expect directories:\n\n\n\n'''\nif [ -d \"$LINK_OR_DIR\" ]; then \n  if [ -L \"$LINK_OR_DIR\" ]; then\n    # It is a symlink!\n    # Symbolic link specific commands go here.\n    rm \"$LINK_OR_DIR\"\n  else\n    # It's a directory!\n    # Directory command goes here.\n    rmdir \"$LINK_OR_DIR\"\n  fi\nfi\n'''\n\n\n\n\n\nTake particular note of the double-quotes used to wrap the variables. The reason for this is explained by 8jean \nin another answer\n.\n\n\nIf the variables contain spaces or other unusual characters it will probably cause the script to fail."
  },
  {
    "instruction": "How do I delete a commit from a branch?",
    "response": "Careful:\n \ngit reset --hard\n \nWILL DELETE YOUR WORKING DIRECTORY CHANGES\n.\nBe sure to \nstash any local changes you want to keep\n before running this command.\n\n\nAssuming you are sitting on that commit, then this command will wack it...\n\n\n\n'''\ngit reset --hard HEAD~1\n'''\n\n\n\nThe \nHEAD~1\n means the commit before head.\n\n\nOr, you could look at the output of \ngit log\n, find the commit id of the commit you want to back up to, and then do this:\n\n\n\n'''\ngit reset --hard <sha1-commit-id>\n'''\n\n\n\n\n\nIf you already pushed it, you will need to do a force push to get rid of it...\n\n\n\n'''\ngit push origin HEAD --force\n'''\n\n\n\nHowever\n, if others may have pulled it, then you would be better off starting a new branch.  Because when they pull, it will just merge it into their work, and you will get it pushed back up again.\n\n\nIf you already pushed, it may be better to use \ngit revert\n, to create a \"mirror image\" commit that will undo the changes.  However, both commits will be in the log.\n\n\n\n\nFYI: \ngit reset --hard HEAD\n is great if you want to get rid of WORK IN PROGRESS.It will reset you back to the most recent commit, and erase all the changes in your working tree and index.\n\n\ngit stash\n does the same except you can restore it later if you need\n, versus permanently delete with reset hard mode. Check your stashes by using \ngit stash list\n and \ngit stash show 'stash@123'\n\n\n\n\nLastly, if you need to find a commit that you \"deleted\", it is typically present in \ngit reflog\n unless you have garbage collected your repository."
  },
  {
    "instruction": "Undoing a git rebase",
    "response": "The easiest way would be to find the head commit of the branch as it was immediately before the rebase started in the \nreflog\n...\n\n\n\n'''\ngit reflog\n'''\n\n\n\nand to reset the current branch to it.\n\n\nSuppose the old commit was \nHEAD@{2}\n in the ref log:\n\n\n\n'''\ngit reset --soft \"HEAD@{2}\"\n'''\n\n\n\n(If you do not want to retain the working copy changes, you can use \n--hard\n instead of \n--soft\n)\n\n\nYou can check the history of the candidate old head by just doing a \ngit log \"HEAD@{2}\"\n.\n\n\nIf you've not disabled per branch reflogs you should be able to simply do \ngit reflog \"branchname@{1}\"\n as a rebase detaches the branch head before reattaching to the final head. I would double-check this behavior, though, as I haven't verified it recently.\n\n\nPer default, all reflogs are activated for non-bare repositories:\n\n\n\n'''\n[core]\n    logAllRefUpdates = true\n'''"
  },
  {
    "instruction": "How do I get the current branch name in Git?",
    "response": "'''\ngit branch\n'''\n\n\n\nshould show all the local branches of your repo. The starred branch is your current branch.\n\n\n\n\nTo retrieve only the name of the branch you are on:\n\n\n\n'''\ngit rev-parse --abbrev-ref HEAD\n'''\n\n\n\nVersion 2.22 adds the \n--show-current\n option to \n”print the name of the current branch”\n. The combination also works for freshly initialized repositories before the first commit:\n\n\n\n'''\ngit branch --show-current\n'''"
  },
  {
    "instruction": "How do I clone a specific Git branch?",
    "response": "'''\ngit clone --single-branch --branch <branchname> <remote-repo>\n'''\n\n\n\nThe \n--single-branch\n option is valid from version \n1.7.10\n and later.\n\n\nPlease see also the \nother answer\n which many people prefer.\n\n\nYou may also want to make sure you understand the difference. And the difference is: by invoking \ngit clone --branch <branchname> url\n you're fetching \nall\n the branches and checking out one. That may, for instance, mean that your repository has a 5kB documentation or wiki branch and 5GB data branch. And whenever you want to edit your frontpage, you may end up cloning 5GB of data.\n\n\nAgain, that is not to say \ngit clone --branch\n is not the way to accomplish that, it's just that it's not \nalways\n what you want to accomplish, when you're asking about cloning a specific branch."
  },
  {
    "instruction": "How do I tell if a file does not exist in Bash?",
    "response": "The \ntest\n command (written as \n[\n here) has a \"not\" logical operator, \n!\n (exclamation mark):\n\n\n\n'''\nif [ ! -f /tmp/foo.txt ]; then\n    echo \"File not found!\"\nfi\n'''"
  },
  {
    "instruction": "grep: show lines surrounding each match",
    "response": "For \nBSD\n or \nGNU\n \ngrep\n you can use \n-B num\n to set how many lines before the match and \n-A num\n for the number of lines after the match.\n\n\n\n'''\ngrep -B 3 -A 2 foo README.txt\n'''\n\n\n\nIf you want the same number of lines before and after you can use \n-C num\n.\n\n\n\n'''\ngrep -C 3 foo README.txt\n'''\n\n\n\nThis will show 3 lines before and 3 lines after."
  },
  {
    "instruction": "Make an existing Git branch track a remote branch?",
    "response": "Given a branch \nfoo\n and a remote \nupstream\n:\n\n\nAs of Git 1.8.0:\n\n\n\n'''\ngit branch -u upstream/foo\n'''\n\n\n\nOr, if local branch \nfoo\n is not the current branch:\n\n\n\n'''\ngit branch -u upstream/foo foo\n'''\n\n\n\nOr, if you like to type longer commands, these are equivalent to the above two:\n\n\n\n'''\ngit branch --set-upstream-to=upstream/foo\n\ngit branch --set-upstream-to=upstream/foo foo\n'''\n\n\n\nAs of Git 1.7.0 (before 1.8.0):\n\n\n\n'''\ngit branch --set-upstream foo upstream/foo\n'''\n\n\n\nNotes:\n\n\n\n\nAll of the above commands will cause local branch \nfoo\n to track remote branch \nfoo\n from remote \nupstream\n.\n\n\nThe old (1.7.x) syntax is deprecated in favor of the new (1.8+) syntax.  The new syntax is intended to be more intuitive and easier to remember.\n\n\nDefining an upstream branch will fail when run against newly-created remotes that have not already been fetched. In that case, run \ngit fetch upstream\n beforehand.\n\n\n\n\n\n\nSee also: \nWhy do I need to do `--set-upstream` all the time?"
  },
  {
    "instruction": "Remove a file from a Git repository without deleting it from the local filesystem",
    "response": "The \ngit rm\n documentation states:\n\n\n\n\nWhen \n--cached\n is given, the staged content has to match either the tip of the branch or the file on disk, allowing the file to be removed from just the index.\n\n\n\n\nSo, for a single file:\n\n\n\n'''\ngit rm --cached file_to_remove.txt\n'''\n\n\n\nand for a single directory:\n\n\n\n'''\ngit rm --cached -r directory_to_remove\n'''"
  },
  {
    "instruction": "Move existing, uncommitted work to a new branch in Git",
    "response": "Update 2020 / Git 2.23\n\n\nGit 2.23 adds the new \nswitch\n subcommand in an attempt to clear some of the confusion that comes from the overloaded usage of \ncheckout\n (switching branches, restoring files, detaching HEAD, etc.)\n\n\nStarting with this version of Git, replace the checkout command with:\n\n\n\n'''\ngit switch -c <new-branch>\n'''\n\n\n\nThe behavior is identical and remains unchanged.\n\n\n\n\nBefore Update 2020 / Git 2.23\n\n\nUse the following:\n\n\n\n'''\ngit checkout -b <new-branch>\n'''\n\n\n\nThis will leave your current branch as it is, create and checkout a new branch and keep all your changes. You can then stage changes in files to commit with:\n\n\n\n'''\ngit add <files>\n'''\n\n\n\nand commit to your \nnew branch\n with:\n\n\n\n'''\ngit commit -m \"<Brief description of this commit>\"\n'''\n\n\n\nThe changes in the working directory and changes staged in index \ndo not belong to any branch\n yet. This changes the branch where those modifications would end in.\n\n\nYou don't \nreset\n your original branch, it stays as it is. The last commit on \n<old-branch>\n will still be the same. Therefore you \ncheckout -b\n and then commit."
  },
  {
    "instruction": "View the change history of a file using Git versioning",
    "response": "For a graphical view, use \ngitk\n:\n\n\n\n'''\ngitk [filename]\n'''\n\n\n\nTo follow the file across file renames:\n\n\n\n'''\ngitk --follow [filename]\n'''"
  },
  {
    "instruction": "How do I stash only one file out of multiple files that have changed?",
    "response": "'''\ngit stash push -p -m \"my commit message\"\n'''\n\n\n\n-p\n let's you select the hunks that should be stashed; whole files can be selected as well.\n\n\nYou'll be prompted with a few actions for each hunk:\n\n\n\n'''\ny - stash this hunk\n   n - do not stash this hunk\n   q - quit; do not stash this hunk or any of the remaining ones\n   a - stash this hunk and all later hunks in the file\n   d - do not stash this hunk or any of the later hunks in the file\n   g - select a hunk to go to\n   / - search for a hunk matching the given regex\n   j - leave this hunk undecided, see next undecided hunk\n   J - leave this hunk undecided, see next hunk\n   k - leave this hunk undecided, see previous undecided hunk\n   K - leave this hunk undecided, see previous hunk\n   s - split the current hunk into smaller hunks\n   e - manually edit the current hunk\n   ? - print help\n'''"
  },
  {
    "instruction": "How do I create a remote Git branch?",
    "response": "Simple Git 2.0+ solution:\n\n\nAs of \nGit 2.0, the behavior has become simpler\n:\n\n\nYou can configure git with \npush.default = current\n to make life easier:\n\n\nI added this so now I can just push a new branch upstream with\n\n\n\n'''\n$ git push -u\n'''\n\n\n\n-u\n will track remote branch of the same name. Now with this configuration, you will auto-guess the remote reference to git push. From \ngit.config documentation\n:\n\n\n\n\npush.default\n\n\nDefines the action git push should take if no refspec is explicitly given.\n\n\npush.default = current\n - push the current branch to update a branch with the\nsame name on the receiving end. Works in both central and non-central workflows.\n\n\n\n\nFor me, this is a good simplification of my day-to-day Git workflow. The configuration setting takes care of the 'usual' use case where you add a branch locally and want to create it remotely. Also, I can just as easily create local branches from remotes by just doing \ngit co remote_branch_name\n (as opposed to using \n--set-upstream-to\n flag).\n\n\nI know this question and the accepted answers are rather old, but the behavior has changed so that now configuration options exist to make your workflow simpler.\n\n\nTo add to your global Git configuration, run this on the command line:\n\n\n\n'''\n$ git config --global push.default current\n'''"
  },
  {
    "instruction": "Commit only part of a file's changes in Git",
    "response": "You can use:\n\n\n\n'''\ngit add --patch <filename>\n'''\n\n\n\nor for short:\n\n\n\n'''\ngit add -p <filename>\n'''\n\n\n\nGit will break down your file into what it thinks are sensible \"hunks\" (portions of the file). It will then prompt you with this question:\n\n\n\n'''\nStage this hunk [y,n,q,a,d,/,j,J,g,s,e,?]?\n'''\n\n\n\nHere is a description of each option:\n\n\n\n\ny\n stage this hunk for the next commit\n\n\nn\n do not stage this hunk for the next commit\n\n\nq\n quit; do not stage this hunk or any of the remaining hunks\n\n\na\n stage this hunk and all later hunks in the file\n\n\nd\n do not stage this hunk or any of the later hunks in the file\n\n\ng\n select a hunk to go to\n\n\n/\n search for a hunk matching the given regex\n\n\nj\n leave this hunk undecided, see next undecided hunk\n\n\nJ\n leave this hunk undecided, see next hunk\n\n\nk\n leave this hunk undecided, see previous undecided hunk\n\n\nK\n leave this hunk undecided, see previous hunk\n\n\ns\n split the current hunk into smaller hunks\n\n\ne\n manually edit the current hunk\n\n\n\nYou can then edit the hunk manually by replacing \n+\n/\n-\n by \n#\n (thanks \nveksen\n)\n\n\n\n\n\n\n?\n print hunk help\n\n\n\n\nIf the file is not in the repository yet, you can first do \ngit add -N <filename>\n. Afterwards you can go on with \ngit add -p <filename>\n.\n\n\nAfterwards, you can use:\n\n\n\n\ngit diff --staged\n to check that you staged the correct changes\n\n\ngit reset -p\n to unstage mistakenly added hunks\n\n\ngit commit -v\n to view your commit while you edit the commit message.\n\n\n\n\nNote this is far different than the \ngit format-patch\n command, whose purpose is to parse commit data into a \n.patch\n files.\n\n\nReference for future: \nGit Tools - Interactive Staging"
  },
  {
    "instruction": "How do I list all the files in a commit?",
    "response": "Preferred Way\n (because it's a \nplumbing\n command; meant to be programmatic):\n\n\n\n'''\n$ git diff-tree --no-commit-id --name-only bd61ad98 -r\nindex.html\njavascript/application.js\njavascript/ie6.js\n'''\n\n\n\nAnother Way\n (less preferred for scripts, because it's a \nporcelain\n command; meant to be user-facing)\n\n\n\n'''\n$ git show --pretty=\"\" --name-only bd61ad98    \nindex.html\njavascript/application.js\njavascript/ie6.js\n'''\n\n\n\n\n\n\n\nThe \n--no-commit-id\n suppresses the commit ID output.\n\n\nThe \n--pretty\n argument specifies an empty format string to avoid the cruft at the beginning.\n\n\nThe \n--name-only\n argument shows only the file names that were affected (Thanks Hank). Use \n--name-status\n instead, if you want to see what happened to each file (\nD\neleted, \nM\nodified, \nA\ndded)\n\n\nThe \n-r\n argument is to recurse into sub-trees"
  },
  {
    "instruction": "Echo newline in Bash prints literal \\n",
    "response": "Use \nprintf\n instead:\n\n\n\n'''\nprintf \"hello\\nworld\\n\"\n'''\n\n\n\nprintf\n behaves more consistently across different environments than \necho\n."
  },
  {
    "instruction": "How to check if a string contains a substring in Bash",
    "response": "You can use \nMarcus's answer (* wildcards)\n outside a case statement, too, if you use double brackets:\n\n\n\n'''\nstring='My long string'\nif [[ $string == *\"My long\"* ]]; then\n  echo \"It's there!\"\nfi\n'''\n\n\n\nNote that spaces in the needle string need to be placed between double quotes, and the \n*\n wildcards should be outside. Also note that a simple comparison operator is used (i.e. \n==\n), not the regex operator \n=~\n."
  },
  {
    "instruction": "How do you push a tag to a remote repository using Git?",
    "response": "To push specific, one tag do following\n\ngit push origin tag_name"
  },
  {
    "instruction": "How to concatenate string variables in Bash",
    "response": "'''\nfoo=\"Hello\"\nfoo=\"${foo} World\"\necho \"${foo}\"\n> Hello World\n'''\n\n\n\nIn general to concatenate two variables you can just write them one after another:\n\n\n\n'''\na='Hello'\nb='World'\nc=\"${a} ${b}\"\necho \"${c}\"\n> Hello World\n'''"
  },
  {
    "instruction": "How to add images to README.md on GitHub?",
    "response": "Try this markdown:\n\n\n\n'''\n![alt text](http://url/to/img.png)\n'''\n\n\n\nI think you can link directly to the raw version of an image if it's stored in your repository. i.e.\n\n\n\n'''\n![alt text](https://github.com/[username]/[reponame]/blob/[branch]/image.jpg?raw=true)\n'''"
  },
  {
    "instruction": "Git is not working after macOS update (\"xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools\")",
    "response": "The problem is that Xcode Command-line Tools needs to be updated due to a MacOs update.\n\n\n\n\nDid not run into this on Sonoma.\n\n\n\nMaybe Apple fixed the process?\n\n\n\n\n\n\nUpdated for Ventura\n\n\n\n\nAfter opening the terminal after restarting, I tried to go to my code, and do a \ngit status\n, and I got an error and prompt for command line software agreement:\n\n\nSo press space until you get to the \n[agree, print, cancel]\n option, so careful hit space to scroll down to the end, if you blow past It you have to run a command to get it back. Use \nsudo xcodebuild -license\n to get to it again.\n\n\nJust be careful on scrolling down and enter \nagree\n and press return and it will launch into an update.\n\n\n\n\nThen I tried to use git after the install, and it prompted me to install Xcode tools again.\n\n\nI followed my own advice from previous years (see below), and went to \nhttps://developer.apple.com/download/all\n and downloaded\n\"Command Line Tools for Xcode 14\" (You have to log in with your Apple ID and enter MFA code, so have all the devices you need for that handy. Then select \"Command Line Tools for Xcode 14\", or if you want to get into the alphas or betas, that's up to you. But stable releases are probably the best choice for software developers.\n\n\n\n\nYou have to either download the tools from CLI or the developer page and before you can use git, you need to reboot!!! Or you will get stuck in a loop of prompt & downloading\n\n\nRebooting will break the loop and complete the installation of your CLI tools \nincluding\n git so that you can get back to work\n\n\nSolutions for previous years, these may or may not be valid these days as the downloads page has changed significantly:\n\n\nPREVIOUS YEARS SOLUTIONS, probably #2 is most helpful.\n\n\n*** \nSolution #1\n:\n\n\nGo back to your terminal and enter:\n\n\n\n'''\nxcode-select --install\n'''\n\n\n\nYou'll then receive the following output:\n\n\n\n'''\nxcode-select: note: install requested for command line developer tools\n'''\n\n\n\nYou will then be prompted in a window to update Xcode Command Line tools. (which could take a while)\n\n\nOpen a new terminal window and your development tools should be returned.\n\n\nAddition:\n With any major or semi-major update you'll need to update the command line tools in order to get them functioning properly again. Check Xcode with any update. This goes beyond Mojave...\n\n\nAfter that restart your terminal\n\n\nAlternatively, \nIF that fails,\n and it might.... you'll get a pop-up box saying \"Software not found on server\", proceed to solution 2.\n\n\n*** \nSolution #2\n: (Preferred method)\n\n\nIf you hit \nxcode-select --install\n and it doesn't find the software, log into Apple Developer, and install it via webpage.\n\n\nLog in or sign up here:\n\n\nhttps://developer.apple.com/download/more/\n\n\nLook for: \n\"Command Line Tools for Xcode 14.x\"\n in the list of downloads\nThen click the dmg and download. (See previous image above) either way, you will probably wind up at an apple downloads webpage."
  },
  {
    "instruction": "Difference between \"git add -A\" and \"git add .\"",
    "response": "This answer only applies to \nGit version 1.x\n. For Git version 2.x, see other answers.\n\n\n\n\nSummary:\n\n\n\n\ngit add -A\n stages \nall changes\n\n\n\n\ngit add .\n stages new files and modifications, \nwithout deletions\n (on the current directory and its subdirectories).\n\n\n\n\ngit add -u\n stages modifications and deletions, \nwithout new files\n\n\n\n\n\n\n\n\nDetail:\n\n\ngit add -A\n is equivalent to  \ngit add .; git add -u\n.\n\n\nThe important point about \ngit add .\n is that it looks at the working tree and adds all those paths to the staged changes if they are either changed or are new and not ignored, it does not stage any 'rm' actions.\n\n\ngit add -u\n looks at all the \nalready\n tracked files and stages the changes to those files if they are different or if they have been removed. It does not add any new files, it only stages changes to already tracked files.\n\n\ngit add -A\n is a handy shortcut for doing both of those.\n\n\nYou can test the differences out with something like this (note that for Git version 2.x your output for \ngit add .\n \ngit status\n \nwill\n be different):\n\n\n\n'''\ngit init\necho Change me > change-me\necho Delete me > delete-me\ngit add change-me delete-me\ngit commit -m initial\n\necho OK >> change-me\nrm delete-me\necho Add me > add-me\n\ngit status\n# Changed but not updated:\n#   modified:   change-me\n#   deleted:    delete-me\n# Untracked files:\n#   add-me\n\ngit add .\ngit status\n\n# Changes to be committed:\n#   new file:   add-me\n#   modified:   change-me\n# Changed but not updated:\n#   deleted:    delete-me\n\ngit reset\n\ngit add -u\ngit status\n\n# Changes to be committed:\n#   modified:   change-me\n#   deleted:    delete-me\n# Untracked files:\n#   add-me\n\ngit reset\n\ngit add -A\ngit status\n\n# Changes to be committed:\n#   new file:   add-me\n#   modified:   change-me\n#   deleted:    delete-me\n'''"
  },
  {
    "instruction": "How do I make git use the editor of my choice for editing commit messages?",
    "response": "Setting the default editor for Git\n\n\nPick one:\n\n\n\n\nSet \ncore.editor\n in your Git config:\n\n\n\n'''\ngit config --global core.editor \"vim\"\n'''\n\n\n\n\n\nSet the \nGIT_EDITOR\n environment variable:\n\n\n\n'''\nexport GIT_EDITOR=vim\n'''\n\n\n\n\n\n\n\n\n\nSetting the default editor for all programs\n\n\nSet the standardized \nVISUAL\n and \nEDITOR\n environment variables*:\n\n\n\n'''\nexport VISUAL=vim\nexport EDITOR=\"$VISUAL\"\n'''\n\n\n\nNOTE:\n Setting both is not necessarily needed, but some programs may not use the more-correct \nVISUAL\n. See \nVISUAL\n vs. \nEDITOR\n.\n\n\n\n\nFixing compatibility issues\n\n\nSome editors require a \n--wait\n flag, or they will open a blank page. For example:\n\n\n\n\nSublime Text\n (if \ncorrectly set up\n; or use the full path to the executable in place of \nsubl\n):\n\n\n\n'''\nexport VISUAL=\"subl --wait\"\n'''\n\n\n\n\n\nVS Code\n (after adding the \nshell command\n):\n\n\n\n'''\nexport VISUAL=\"code --wait\"\n'''"
  },
  {
    "instruction": "What does cherry-picking a commit with Git mean?",
    "response": "Cherry-picking in Git means choosing a commit from one branch and applying it to another.\n\n\nThis contrasts with other ways such as \nmerge\n and \nrebase\n which normally apply many commits to another branch.\n\n\nIt's also possible to \ncherry-pick multiple commits\n but \nmerge\n is the preferred way over cherry-picking.\n\n\n\n\nMake sure you are on the branch you want to apply the commit to.\n\n\n\n'''\ngit switch master\n'''\n\n\n\n\n\nExecute the following:\n\n\n\n'''\ngit cherry-pick <commit-hash>\n'''\n\n\n\n\n\n\n\nN.B.:\n\n\n\n\nIf you cherry-pick from a public branch, you should consider using\n\n\n\n'''\ngit cherry-pick -x <commit-hash>\n'''\n\n\n\nThis will generate a standardized commit message. This way, you (and your co-workers) can still keep track of the origin of the commit and may avoid merge conflicts in the future.\n\n\n\n\nIf you have notes attached to the commit they do not follow the cherry-pick. To bring them over as well, You have to use:\n\n\n\n'''\ngit notes copy <from> <to>\n'''\n\n\n\n\n\n\n\nAdditional links:\n\n\n\n\ngit official guide page\n\n\ngit cherry-pick guide"
  },
  {
    "instruction": "How do I modify a specific commit?",
    "response": "Use \ngit rebase\n. For example, to modify commit \nbbc643cd\n, run:\n\n\n\n'''\ngit rebase --interactive bbc643cd~\n'''\n\n\n\nPlease note the tilde \n~\n at the end of the command, because you need to reapply commits on top of the previous commit of \nbbc643cd\n (i.e. \nbbc643cd~\n).\n\n\nIn the default editor, modify \npick\n to \nedit\n in the line mentioning \nbbc643cd\n.\n\n\nSave the file and exit. git will interpret and automatically execute the commands in the file. You will find yourself in the previous situation in which you just had created commit \nbbc643cd\n.\n\n\nAt this point, \nbbc643cd\n is your last commit and you can \neasily amend it\n. Make your changes and then commit them with the command:\n\n\n\n'''\ngit commit --all --amend --no-edit\n'''\n\n\n\nAfter that, return back to the previous HEAD commit using:\n\n\n\n'''\ngit rebase --continue\n'''\n\n\n\nWARNING\n: Note that this will change the SHA-1 of that commit \nas well as all children\n -- in other words, this rewrites the history from that point forward. \nYou can break repos doing this\n if you push using the command \ngit push --force\n."
  },
  {
    "instruction": "How can I change the commit author for a single commit?",
    "response": "Interactive rebase off of a point earlier in the history than the commit you need to modify (\ngit rebase -i <earliercommit>\n). In the list of commits being rebased, change the text from \npick\n to \nedit\n next to the hash of the one you want to modify. Then when git prompts you to change the commit, use this:\n\n\n\n'''\ngit commit --amend --author=\"Author Name <email@address.com>\" --no-edit\n'''\n\n\n\n\n\nFor example, if your commit history is \nA-B-C-D-E-F\n with \nF\n as \nHEAD\n, and you want to change the author of \nC\n and \nD\n, then you would...\n\n\n\n\nSpecify \ngit rebase -i B\n (\nhere is an example of what you will see after executing the \ngit rebase -i B\n command\n)\n\n\n\n\nif you need to edit \nA\n, use \ngit rebase -i --root\n\n\n\n\nChange the lines for both \nC\n and \nD\n from \npick\n to \nedit\n\n\nExit the editor (for vim, this would be pressing Esc and then typing \n:wq\n).\n\n\nOnce the rebase started, it would first pause at \nC\n\n\nYou would \ngit commit --amend --author=\"Author Name <email@address.com>\"\n\n\nThen \ngit rebase --continue\n\n\nIt would pause again at \nD\n\n\nThen you would \ngit commit --amend --author=\"Author Name <email@address.com>\"\n again\n\n\ngit rebase --continue\n\n\nThe rebase would complete.\n\n\nUse \ngit push -f\n to update your origin with the updated commits."
  },
  {
    "instruction": "How do I find and restore a deleted file in a Git repository?",
    "response": "Find the last commit that affected the given path. As the file isn't in the HEAD commit, that previous commit must have deleted it.\n\n\n\n'''\ngit rev-list -n 1 HEAD -- <file_path>\n'''\n\n\n\nThen checkout the version at the commit before, using the caret (\n^\n) symbol:\n\n\n\n'''\ngit checkout <deleting_commit>^ -- <file_path>\n'''\n\n\n\nOr in one command, if \n$file\n is the file in question.\n\n\n\n'''\ngit checkout $(git rev-list -n 1 HEAD -- \"$file\")^ -- \"$file\"\n'''\n\n\n\n\n\nIf you are using zsh and have the EXTENDED_GLOB option enabled, the caret symbol won't work. You can use \n~1\n instead.\n\n\n\n'''\ngit checkout $(git rev-list -n 1 HEAD -- \"$file\")~1 -- \"$file\"\n'''"
  },
  {
    "instruction": "What does \" 2>&1 \" mean?",
    "response": "File descriptor 1 is the standard output (\nstdout\n).\n\nFile descriptor 2 is the standard error (\nstderr\n).\n\n\nAt first, \n2>1\n may look like a good way to redirect \nstderr\n to \nstdout\n. However, it will actually be interpreted as \"redirect \nstderr\n to a file named \n1\n\".\n\n\n&\n indicates that what follows and precedes is a \nfile descriptor\n, and not a filename. Thus, we use \n2>&1\n. Consider \n>&\n to be a redirect merger operator."
  },
  {
    "instruction": "`git fetch` a remote branch",
    "response": "Update: Using Git Switch\n\n\nAll of the information written below was accurate, but a new command, \ngit switch\n has been added that simplifies the effort.\n\n\nIf \ndaves_branch\n exists on the remote repository, but not on your local branch, you can simply type:\n\n\n\n'''\ngit switch daves_branch\n'''\n\n\n\nSince you do not have the branch locally, this will automatically make \nswitch\n look on the remote repo.  It will then also automatically set up remote branch tracking.\n\n\nNote that if \ndaves_branch\n doesn't exist locally you'll need to \ngit fetch\n first before using \nswitch\n.\n\n\n\n\nOriginal Post\n\n\nYou need to create a local branch that tracks a remote branch. The following command will create a local branch named \ndaves_branch\n, tracking the remote branch \norigin/daves_branch\n. When you push your changes the remote branch will be updated.\n\n\nFor most recent versions of Git:\n\n\n\n'''\ngit checkout --track origin/daves_branch\n'''\n\n\n\n--track\n is shorthand for \ngit checkout -b [branch] [remotename]/[branch]\n where [remotename] is \norigin\n in this case and [branch] is twice the same, \ndaves_branch\n in this case.\n\n\nFor Git 1.5.6.5 you needed this:\n\n\n\n'''\ngit checkout --track -b daves_branch origin/daves_branch\n'''\n\n\n\nFor Git 1.7.2.3 and higher, this is enough (it might have started earlier, but this is the earliest confirmation I could find quickly):\n\n\n\n'''\ngit checkout daves_branch\n'''\n\n\n\nNote that with recent Git versions, this command will not create a local branch and will put you in a 'detached HEAD' state. If you want a local branch, use the \n--track\n option.\n\n\nFull details are here: \n3.5 Git Branching - Remote Branches, Tracking Branches"
  },
  {
    "instruction": "How can I check if a program exists from a Bash script?",
    "response": "Answer\n\n\nPOSIX compatible:\n\n\n\n'''\ncommand -v <the_command>\n'''\n\n\n\nExample use:\n\n\n\n'''\nif ! command -v <the_command> >/dev/null 2>&1\nthen\n    echo \"<the_command> could not be found\"\n    exit 1\nfi\n'''\n\n\n\nFor Bash specific environments:\n\n\n\n'''\nhash <the_command> # For regular commands. Or...\ntype <the_command> # To check built-ins and keywords\n'''\n\n\n\nExplanation\n\n\nAvoid \nwhich\n. Not only is it an external process you're launching for doing very little (meaning builtins like \nhash\n, \ntype\n or \ncommand\n are way cheaper), you can also rely on the builtins to actually do what you want, while the effects of external commands can easily vary from system to system.\n\n\nWhy care?\n\n\n\n\nMany operating systems have a \nwhich\n that \ndoesn't even set an exit status\n, meaning the \nif which foo\n won't even work there and will \nalways\n report that \nfoo\n exists, even if it doesn't (note that some POSIX shells appear to do this for \nhash\n too).\n\n\nMany operating systems make \nwhich\n do custom and evil stuff like change the output or even hook into the package manager.\n\n\n\n\nSo, don't use \nwhich\n. Instead use one of these:\n\n\n\n'''\ncommand -v foo >/dev/null 2>&1 || { echo >&2 \"I require foo but it's not installed.  Aborting.\"; exit 1; }\n'''\n\n\n\n\n'''\ntype foo >/dev/null 2>&1 || { echo >&2 \"I require foo but it's not installed.  Aborting.\"; exit 1; }\n'''\n\n\n\n\n'''\nhash foo 2>/dev/null || { echo >&2 \"I require foo but it's not installed.  Aborting.\"; exit 1; }\n'''\n\n\n\n(Minor side-note: some will suggest \n2>&-\n is the same \n2>/dev/null\n but shorter – \nthis is untrue\n.  \n2>&-\n closes FD 2 which causes an \nerror\n in the program when it tries to write to stderr, which is very different from successfully writing to it and discarding the output (and dangerous!))\n\n(Additional minor side-note: some will suggest \n&>/dev/null\n, but this \nis not POSIX compliant\n)\n\n\nIf your hash bang is \n/bin/sh\n then you should care about what POSIX says. \ntype\n and \nhash\n's exit codes aren't terribly well defined by POSIX, and \nhash\n is seen to exit successfully when the command doesn't exist (haven't seen this with \ntype\n yet).  \ncommand\n's exit status is well defined by POSIX, so that one is probably the safest to use.\n\n\nIf your script uses \nbash\n though, POSIX rules don't really matter anymore and both \ntype\n and \nhash\n become perfectly safe to use. \ntype\n now has a \n-P\n to search just the \nPATH\n and \nhash\n has the side-effect that the command's location will be hashed (for faster lookup next time you use it), which is usually a good thing since you probably check for its existence in order to actually use it.\n\n\nAs a simple example, here's a function that runs \ngdate\n if it exists, otherwise \ndate\n:\n\n\n\n'''\ngnudate() {\n    if hash gdate 2>/dev/null; then\n        gdate \"$@\"\n    else\n        date \"$@\"\n    fi\n}\n'''"
  },
  {
    "instruction": "How do I change the author and committer name/email for multiple commits?",
    "response": "This answer uses \ngit-filter-branch\n, for which \nthe docs\n now give this warning:\n\n\ngit filter-branch has a plethora of pitfalls that can produce non-obvious manglings of the intended history rewrite (and can leave you with little time to investigate such problems since it has such abysmal performance). These safety and performance issues cannot be backward compatibly fixed and as such, its use is not recommended. Please use an alternative history filtering tool such as \ngit filter-repo\n. If you still need to use git filter-branch, please carefully read \nSAFETY\n (and \nPERFORMANCE\n) to learn about the land mines of filter-branch, and then vigilantly avoid as many of the hazards listed there as reasonably possible.\n\n\n\n\nChanging the author (or committer) would require rewriting all of the history.  If you're okay with that and think it's worth it then you should check out \ngit filter-branch\n.  The manual page includes several examples to get you started.  Also note that you can use environment variables to change the name of the author, committer, dates, etc. -- see the \"Environment Variables\" section of the \ngit manual page\n.\n\n\nSpecifically, you can fix all the wrong author names and emails \nfor all branches and tags\n with this command (source: \nGitHub help\n):\n\n\n\n'''\n#!/bin/sh\n\ngit filter-branch --env-filter '\nOLD_EMAIL=\"your-old-email@example.com\"\nCORRECT_NAME=\"Your Correct Name\"\nCORRECT_EMAIL=\"your-correct-email@example.com\"\nif [ \"$GIT_COMMITTER_EMAIL\" = \"$OLD_EMAIL\" ]\nthen\n    export GIT_COMMITTER_NAME=\"$CORRECT_NAME\"\n    export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\"\nfi\nif [ \"$GIT_AUTHOR_EMAIL\" = \"$OLD_EMAIL\" ]\nthen\n    export GIT_AUTHOR_NAME=\"$CORRECT_NAME\"\n    export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\"\nfi\n' --tag-name-filter cat -- --branches --tags\n'''\n\n\n\nFor using alternative history filtering tool \ngit filter-repo\n, you can first install it and construct a \ngit-mailmap\n according to the format of \ngitmailmap\n.\n\n\n\n'''\nProper Name <proper@email.xx> Commit Name <commit@email.xx>\n'''\n\n\n\nAnd then run filter-repo with the created mailmap:\n\n\n\n'''\ngit filter-repo --mailmap git-mailmap\n'''"
  },
  {
    "instruction": "How do I clone a Git repository into a specific folder?",
    "response": "Option A:\n\n\n\n'''\ngit clone git@github.com:whatever folder-name\n'''\n\n\n\nErgo, for \nright here\n use:\n\n\n\n'''\ngit clone git@github.com:whatever .\n'''\n\n\n\nOption B:\n\n\nMove the \n.git\n folder, too. Note that the \n.git\n folder is hidden in most graphical file explorers, so be sure to show hidden files.\n\n\n\n'''\nmv /where/it/is/right/now/* /where/I/want/it/\nmv /where/it/is/right/now/.* /where/I/want/it/\n'''\n\n\n\nThe first line grabs all normal files, the second line grabs dot-files. It is also possibe to do it in one line by enabling dotglob (i.e. \nshopt -s dotglob\n) but that is probably a bad solution if you are asking the question this answer answers.\n\n\nBetter yet:\n\n\nKeep your working copy somewhere else, and create a symbolic link. Like this:\n\n\n\n'''\nln -s /where/it/is/right/now /the/path/I/want/to/use\n'''\n\n\n\nFor your case this would be something like:\n\n\n\n'''\nln -sfn /opt/projectA/prod/public /httpdocs/public\n'''\n\n\n\nWhich easily could be changed to test if you wanted it, i.e.:\n\n\n\n'''\nln -sfn /opt/projectA/test/public /httpdocs/public\n'''\n\n\n\nwithout moving files around. Added \n-fn\n in case someone is copying these lines (\n-f\n is force,  \n-n\n avoid some often unwanted interactions with already and non-existing links).\n\n\nIf you just want it to work, use Option A, if someone else is going to look at what you have done, use Option C."
  },
  {
    "instruction": "How do I split a string on a delimiter in Bash?",
    "response": "You can set the \ninternal field separator\n (IFS) variable, and then let it parse into an array. When this happens in a command, then the assignment to \nIFS\n only takes place to that single command's environment (to \nread\n ). It then parses the input according to the \nIFS\n variable value into an array, which we can then iterate over.\n\n\nThis example will parse one line of items separated by \n;\n, pushing it into an array:\n\n\n\n'''\nIFS=';' read -ra ADDR <<< \"$IN\"\nfor i in \"${ADDR[@]}\"; do\n  # process \"$i\"\ndone\n'''\n\n\n\nThis other example is for processing the whole content of \n$IN\n, each time one line of input separated by \n;\n:\n\n\n\n'''\nwhile IFS=';' read -ra ADDR; do\n  for i in \"${ADDR[@]}\"; do\n    # process \"$i\"\n  done\ndone <<< \"$IN\"\n'''"
  },
  {
    "instruction": "How do I make Git ignore file mode (chmod) changes?",
    "response": "Try:\n\n\n\n'''\ngit config core.fileMode false\n'''\n\n\n\nFrom \ngit-config(1)\n:\n\n\n\n\n\n'''\ncore.fileMode\n    Tells Git if the executable bit of files in the working tree\n    is to be honored.\n\n    Some filesystems lose the executable bit when a file that is\n    marked as executable is checked out, or checks out a\n    non-executable file with executable bit on. git-clone(1)\n    or git-init(1) probe the filesystem to see if it handles the \n    executable bit correctly and this variable is automatically\n    set as necessary.\n\n    A repository, however, may be on a filesystem that handles\n    the filemode correctly, and this variable is set to true when\n    created, but later may be made accessible from another\n    environment that loses the filemode (e.g. exporting ext4\n    via CIFS mount, visiting a Cygwin created repository with Git\n    for Windows or Eclipse). In such a case it may be necessary\n    to set this variable to false. See git-update-index(1).\n\n    The default is true (when core.filemode is not specified\n    in the config file).\n'''\n\n\n\n\n\nThe \n-c\n flag can be used to set this option for one-off commands:\n\n\n\n'''\ngit -c core.fileMode=false diff\n'''\n\n\n\nTyping the \n-c core.fileMode=false\n can be bothersome and so you can set this flag for all git repos or just for one git repo:\n\n\n\n'''\n# this will set your the flag for your user for all git repos (modifies `$HOME/.gitconfig`)\n# WARNING: this will be override by local config, fileMode value is automatically selected with latest version of git.\n# This mean that if git detect your current filesystem is compatible it will set local core.fileMode to true when you clone or init a repository.\n# Tool like cygwin emulation will be detected as compatible and so your local setting WILL BE SET to true no matter what you set in global setting.\ngit config --global core.fileMode false\n\n# this will set the flag for one git repo (modifies `$current_git_repo/.git/config`)\ngit config core.fileMode false\n'''\n\n\n\nAdditionally, \ngit clone\n and \ngit init\n explicitly set \ncore.fileMode\n to \ntrue\n in the repo config as discussed in \nGit global core.fileMode false overridden locally on clone\n\n\nWarning\n\n\ncore.fileMode\n is not the best practice and should be used carefully. This setting only covers the executable bit of mode and never the read/write bits. In many cases you think you need this setting because you did something like \nchmod -R 777\n, making all your files executable. But in most projects \nmost files don't need and should not be executable for security reasons\n.\n\n\nThe proper way to solve this kind of situation is to handle folder and file permission separately, with something like:\n\n\n\n'''\nfind . -type d -exec chmod a+rwx {} \\; # Make folders traversable and read/write\nfind . -type f -exec chmod a+rw {} \\;  # Make files read/write\n'''\n\n\n\nIf you do that, you'll never need to use \ncore.fileMode\n, except in very rare environment."
  },
  {
    "instruction": "Extract filename and extension in Bash",
    "response": "First, get file name without the path:\n\n\n\n'''\nfilename=$(basename -- \"$fullfile\")\nextension=\"${filename##*.}\"\nfilename=\"${filename%.*}\"\n'''\n\n\n\nAlternatively, you can focus on the last '/' of the path instead of the '.' which should work even if you have unpredictable file extensions:\n\n\n\n'''\nfilename=\"${fullfile##*/}\"\n'''\n\n\n\nYou may want to check the documentation :\n\n\n\n\nOn the web at section \"\n3.5.3 Shell Parameter Expansion\n\"\n\n\nIn the bash manpage at section called \"Parameter Expansion\""
  },
  {
    "instruction": "Ignore files that have already been committed to a Git repository",
    "response": "To untrack a \nsingle\n file that has already been added/initialized to your repository, \ni.e.\n, stop tracking the file but not delete it from your system use: \ngit rm --cached filename\n\n\nTo untrack \nevery\n file that is now in your \n.gitignore\n:\n\n\nFirst commit any outstanding code changes\n, and then, run this command:\n\n\n\n'''\ngit rm -r --cached .\n'''\n\n\n\nThis removes any changed files from the \nindex\n(staging area), then just run:\n\n\n\n'''\ngit add .\n'''\n\n\n\nCommit it:\n\n\n\n'''\ngit commit -m \".gitignore is now working\"\n'''\n\n\n\n\n\nTo undo \ngit rm --cached filename\n, use \ngit add filename\n.\n\n\n\n\nMake sure to commit all your important changes before running \ngit add .\n\nOtherwise, you will lose any changes to other files.\n\n\n\n\n\n\nPlease be careful, when you push this to a repository and pull from somewhere else into a state where those files are still tracked, the files will be DELETED\n\n\n\n\n\n\nTo remove all files that do not match the paths listed in some path spec file (something that has the same format as a .gitignore file):\n\n\n\n'''\ngit rm --cached --ignore-unmatch -r --pathspec-from-file .ignorelist\n'''\n\n\n\nNote:\n unlike \n.gitignore\n, which can have new lines, \n.ignorelist\n cannot have new lines because \ngit\n will complain about empty patterns not being valid path spec items.\n\n\nExplanation:\n\n\n\n\n-r\n: to allow recursive removal when directories are involved\n\n\n--pathspec-from-file\n: path to file containing the path specifications for files to be removed\n\n\n--ignore-unmatch\n: tell \ngit\n to ignore any path specifications that do not have a matching cache hit (otherwise it will abort with an error on that path spec)"
  },
  {
    "instruction": "See what's in a stash without applying it",
    "response": "From \nman git-stash\n (which can also be obtained via \ngit help stash\n):\n\n\n\n\nThe modifications stashed away by this command can be listed with \ngit stash list\n, inspected with \ngit stash show\n, and ...\n\n\n\n\n\n'''\nshow [<stash>]\n    Show the changes recorded in the stash as a diff between the stashed\n    state and its original parent. When no <stash> is given, shows the\n    latest one. By default, the command shows the diffstat, but it will\n    accept any format known to git diff (e.g., git stash show -p stash@{1}\n    to view the second most recent stash in patch form).\n'''\n\n\n\nNote: the \n-p\n option generates a \npatch\n, as per \ngit-diff\n documentation.\n\n\nList the stashes:\n\n\n\n'''\ngit stash list\n'''\n\n\n\nShow the \nfiles\n in the most recent stash:\n\n\n\n'''\ngit stash show\n'''\n\n\n\nShow the \nchanges\n of the most recent stash:\n\n\n\n'''\ngit stash show -p\n'''\n\n\n\nShow the \nchanges\n of the named stash:\n\n\n\n'''\ngit stash show -p stash@{1}\n'''\n\n\n\nOr in short:\n\n\n\n'''\ngit stash show -p 1\n'''\n\n\n\nIf you want to view changes of only the last stash:\n\n\n\n'''\ngit stash show -p 0\n'''"
  },
  {
    "instruction": "How do I get the hash for the current commit in Git?",
    "response": "To turn any extended object reference into a hash, use \ngit-rev-parse\n:\n\n\n\n'''\ngit rev-parse HEAD\n'''\n\n\n\nor\n\n\n\n'''\ngit rev-parse --verify HEAD\n'''\n\n\n\nAs noted by Alexander's \nanswer\n, you can also retrieve the short hash:\n\n\n\n'''\ngit rev-parse --short HEAD\n'''\n\n\n\nTo turn \nreferences\n (e.g. \nbranches and tags\n) into hashes, use \ngit show-ref\n and \ngit for-each-ref\n."
  },
  {
    "instruction": "How can I save username and password in Git?",
    "response": "Attention:\n\n\nThis method saves the credentials in \nplaintext\n on your PC's disk. Everyone on your computer can access it, e.g. malicious NPM modules.\n\n\nRun\n:\n\n\n\n'''\ngit config --global credential.helper store\n'''\n\n\n\nthen\n:\n\n\n\n'''\ngit pull\n'''\n\n\n\nprovide a username and password and those details will then be remembered later. The credentials are stored in a file on the disk, with the disk permissions of \"just user readable/writable\" but still in plaintext.\n\n\nIf you want to change the password later:\n\n\n\n'''\ngit pull\n'''\n\n\n\nWill fail, because the password is incorrect, git then removes the offending user+password from the \n~/.git-credentials\n file, so now re-run:\n\n\n\n'''\ngit pull\n'''\n\n\n\nto provide a new password so it works as earlier."
  },
  {
    "instruction": "How do I \"git clone\" a repo, including its submodules?",
    "response": "With version 2.13 of Git and later, \n--recurse-submodules\n can be used instead of \n--recursive\n:\n\n\n\n'''\ngit clone --recurse-submodules -j8 git://github.com/foo/bar.git\ncd bar\n'''\n\n\n\nEditor’s note: \n-j8\n is an optional performance optimization that became available in version 2.8, and fetches up to 8 submodules at a time in parallel — see \nman git-clone\n.\n\n\nWith version 1.9 of Git up until version 2.12 (\n-j\n flag only available in version 2.8+):\n\n\n\n'''\ngit clone --recursive -j8 git://github.com/foo/bar.git\ncd bar\n'''\n\n\n\nWith version 1.6.5 of Git and later, you can use:\n\n\n\n'''\ngit clone --recursive git://github.com/foo/bar.git\ncd bar\n'''\n\n\n\nFor already cloned repos, or older Git versions, use:\n\n\n\n'''\ngit clone git://github.com/foo/bar.git\ncd bar\ngit submodule update --init --recursive\n'''"
  },
  {
    "instruction": "How to list only the names of files that changed between two commits",
    "response": "'''\ngit diff --name-only SHA1 SHA2\n'''\n\n\n\nwhere you only need to include enough of the SHA hash to identify the commits. The order of the SHAs does not matter. The output (which includes the relative path, not just the file name) follows this format:\n\n\n\n'''\ndir 1/dir 2/filename.ext\n dir 3/dir 4/other filename.ext\n'''\n\n\n\nYou can also do, for example\n\n\n\n'''\ngit diff --name-only HEAD~10 HEAD~5\n'''\n\n\n\nto see the differences between the tenth latest commit and the fifth latest (or so)."
  },
  {
    "instruction": "Pull latest changes for all git submodules",
    "response": "If it's \nthe first time\n you check-out a repo you need to use \n--init\n first:\n\n\n\n'''\ngit submodule update --init --recursive\n'''\n\n\n\nFor \ngit 1.8.2\n or above, the option \n--remote\n was added to support updating to latest tips of remote branches:\n\n\n\n'''\ngit submodule update --recursive --remote\n'''\n\n\n\nThis has the added benefit of respecting any \"non default\" branches specified in the \n.gitmodules\n or \n.git/config\n files (if you happen to have any, default is origin/master, in which case some of the other answers here would work as well).\n\n\nFor \ngit 1.7.3\n or above you can use (but the below gotchas around what update does still apply):\n\n\n\n'''\ngit submodule update --recursive\n'''\n\n\n\nor:\n\n\n\n'''\ngit pull --recurse-submodules\n'''\n\n\n\nif you want to pull your submodules to latest commits instead of the current commit the repo points to.\n\n\nSee \ngit-submodule(1)\n for details"
  },
  {
    "instruction": "How do I delete all Git branches which have been merged?",
    "response": "NOTE: You can add other branches to exclude like master and dev if your workflow has those as a possible ancestor. Usually I branch off of a \"sprint-start\" tag and \nmaster\n, \ndev\n and \nqa\n are not ancestors.\n\n\n\n\nFirst, list locally-tracking branches that were merged in remote (consider using \n-r\n flag to list all remote-tracking branches).\n\n\n\n'''\ngit branch --merged\n'''\n\n\n\nYou might see a few branches you don't want to remove. We can add arguments to skip important branches that we don't want to delete like master or a develop. The following command will skip the \nmaster\n/\nmain\n branch and anything that has 'dev' in it.\n\n\n\n'''\ngit branch --merged | grep -Ev \"(^\\*|^\\+|master|main|dev)\"\n'''\n\n\n\nThe first part (\n^\\*|^+\n) excludes the current branch and any branch checked out in another worktree.\n\n\nIf you want to skip a branch, you can add it to the grep command as below. The branch \nskip_branch_name\n will not be deleted.\n\n\n\n'''\ngit branch --merged | grep -Ev \"(^\\*|^\\+|master|main|dev|skip_branch_name)\"\n'''\n\n\n\nTo delete all local branches that are already merged into the currently checked out branch:\n\n\n\n'''\ngit branch --merged | grep -Ev \"(^\\*|^\\+|master|main|dev)\" | xargs --no-run-if-empty git branch -d\n'''\n\n\n\nYou can see that \nmaster\n and \ndev\n are excluded in case they are an ancestor.\n\n\n\n\nYou can delete a merged local branch with:\n\n\n\n'''\ngit branch -d branchname\n'''\n\n\n\nTo force deletion of an unmerged branch, use:\n\n\n\n'''\ngit branch -D branchname\n'''\n\n\n\nTo delete it from the remote use:\n\n\n\n'''\ngit push --delete origin branchname\n\ngit push origin :branchname    # for really old git\n'''\n\n\n\nOnce you delete the branch from the remote, you can prune to get rid of remote tracking branches with:\n\n\n\n'''\ngit remote prune origin\n'''\n\n\n\nor prune individual remote tracking branches, as the other answer suggests, with:\n\n\n\n'''\ngit branch -dr branchname\n'''"
  },
  {
    "instruction": "Make .gitignore ignore everything except a few files",
    "response": "An optional prefix \n!\n which negates the pattern; any matching file excluded by\na previous pattern will become included again. If a negated pattern matches,\nthis will override lower precedence patterns sources.\n\n\n\n\n\n'''\n# Ignore everything\n*\n\n# But not these files...\n!.gitignore\n!script.pl\n!template.latex\n# etc...\n\n# ...even if they are in subdirectories\n!*/\n'''"
  },
  {
    "instruction": "How do I revert all local changes in Git managed project to previous state?",
    "response": "To revert changes made to your working copy, do this:\n\n\n\n'''\ngit checkout .\n'''\n\n\n\nOr equivalently, for git version >= 2.23:\n\n\n\n'''\ngit restore .\n'''\n\n\n\nTo revert changes made to the index (i.e., that you have added), do this. \nWarning this will reset all of your unpushed commits to master!\n:\n\n\n\n'''\ngit reset\n'''\n\n\n\nTo revert a change that you have committed:\n\n\n\n'''\ngit revert <commit 1> <commit 2>\n'''\n\n\n\nTo remove untracked files (e.g., new files, generated files):\n\n\n\n'''\ngit clean -f\n'''\n\n\n\nOr untracked directories (e.g., new or automatically generated directories):\n\n\n\n'''\ngit clean -fd\n'''"
  },
  {
    "instruction": "How to branch from a previous commit",
    "response": "Create the branch using a commit hash:\n\n\n\n'''\ngit branch branch_name <commit-hash>\n'''\n\n\n\nOr by using a symbolic reference:\n\n\n\n'''\ngit branch branch_name HEAD~3\n'''\n\n\n\nTo checkout the branch while creating it, use:\n\n\n\n'''\ngit checkout -b branch_name <commit-hash or HEAD~3>\n'''"
  },
  {
    "instruction": "How do I safely merge a Git branch into master?",
    "response": "How I would do this\n\n\n\n'''\ngit checkout master\ngit pull origin master\ngit merge test\ngit push origin master\n'''\n\n\n\nIf I have a local branch from a remote one, I don't feel comfortable with merging other branches than this one with the remote. Also I would not push my changes, until I'm happy with what I want to push and also I wouldn't push things at all, that are only for me and my local repository. In your description it seems, that \ntest\n is only for you? So no reason to publish it.\n\n\ngit always tries to respect yours and others changes, and so will \n--rebase\n. I don't think I can explain it appropriately, so have a look at \nthe Git book - Rebasing\n or \ngit-ready: Intro into rebasing\n for a little description. It's a quite cool feature"
  },
  {
    "instruction": "What are the differences between .gitignore and .gitkeep?",
    "response": ".gitkeep\n isn’t documented, because it’s not a feature of Git.\n\n\nGit \ncannot add a completely empty directory\n. People who want to track empty directories in Git have created the convention of putting files called \n.gitkeep\n in these directories. The file could be called anything; Git assigns no special significance to this name.\n\n\nThere is a competing convention of adding a \n.gitignore\n file to the empty directories to get them tracked, but some people see this as confusing since the goal is to keep the empty directories, not ignore them; \n.gitignore\n is also used to list files that should be ignored by Git when looking for untracked files."
  },
  {
    "instruction": "How do I show the changes which have been staged?",
    "response": "It should just be:\n\n\n\n'''\ngit diff --cached\n'''\n\n\n\n--cached\n means show the changes in the cache/index (i.e. staged changes) against the current \nHEAD\n. \n--staged\n is a synonym for \n--cached\n.\n\n\n--staged\n and \n--cached\n does not point to \nHEAD\n, just difference with respect to \nHEAD\n. If you cherry pick what to commit using \ngit add --patch\n (or \ngit add -p\n), \n--staged\n will return what is staged."
  },
  {
    "instruction": "How do I recover a dropped stash in Git?",
    "response": "Once you know the hash of the stash commit you dropped, you can apply it as a stash:\n\n\n\n'''\ngit stash apply $stash_hash\n'''\n\n\n\nOr, you can create a separate branch for it with\n\n\n\n'''\ngit branch recovered $stash_hash\n'''\n\n\n\nAfter that, you can do whatever you want with all the normal tools. When you’re done, just blow the branch away.\n\n\nFinding the hash\n\n\nIf you have only just popped it and the terminal is still open, you will \nstill have the hash value printed by \ngit stash pop\n on screen\n (thanks, Dolda).\n\n\nOtherwise, you can find this way in Linux, Unix or Git Bash for Windows:\n\n\n\n'''\ngit fsck --no-reflog | awk '/dangling commit/ {print $NF}'\n'''\n\n\n\n… or in PowerShell for Windows:\n\n\n\n'''\ngit fsck --no-reflog | select-string 'dangling commit' | foreach { $_.ToString().Split(\" \")[-1] }\n'''\n\n\n\nThis will show you all the commits at the tips of your commit graph which are no longer referenced from any branch or tag – every lost commit, including every stash commit you’ve ever created, will be somewhere in that graph.\n\n\nThe easiest way to find the stash commit you want is probably to pass that list straight to \ngitk\n:\n\n\n\n'''\ngitk --all $( git fsck --no-reflog | awk '/dangling commit/ {print $NF}' )\n'''\n\n\n\n… or in PowerShell for Windows:\n\n\n\n'''\ngitk --all $( git fsck --no-reflog | select-string 'dangling commit' | foreach { $_.ToString().Split(\" \")[-1] } )\n'''\n\n\n\nThis will launch a repository browser showing you \nevery single commit in the repository ever\n, regardless of whether it is reachable or not.\n\n\nYou can replace \ngitk\n there with something like \ngit log --graph --oneline --decorate\n if you prefer a nice graph on the console over a separate GUI app.\n\n\nTo spot stash commits, look for commit messages of this form:\n\n\n        WIP on \nsomebranch\n: \ncommithash Some old commit message\n\n\nNote\n: The commit message will only be in this form (starting with \"WIP on\") if you did not supply a message when you did \ngit stash\n."
  },
  {
    "instruction": "How do I delete a file from a Git repository?",
    "response": "Use \ngit rm\n.\n\n\nIf you want to remove the file from the Git repository \nand the filesystem\n, use:\n\n\n\n'''\ngit rm file1.txt\ngit commit -m \"remove file1.txt\"\n'''\n\n\n\nBut if you want to remove the file only from the Git repository and not remove it from the filesystem, use:  \n\n\n\n'''\ngit rm --cached file1.txt\ngit commit -m \"remove file1.txt\"\n'''\n\n\n\nAnd to push changes to remote repo\n\n\n\n'''\ngit push origin branch_name\n'''"
  },
  {
    "instruction": "How do I parse command line arguments in Bash?",
    "response": "Bash Space-Separated (e.g., \n--option argument\n)\n\n\n\n'''\ncat >/tmp/demo-space-separated.sh <<'EOF'\n#!/bin/bash\n\nPOSITIONAL_ARGS=()\n\nwhile [[ $# -gt 0 ]]; do\n  case $1 in\n    -e|--extension)\n      EXTENSION=\"$2\"\n      shift # past argument\n      shift # past value\n      ;;\n    -s|--searchpath)\n      SEARCHPATH=\"$2\"\n      shift # past argument\n      shift # past value\n      ;;\n    --default)\n      DEFAULT=YES\n      shift # past argument\n      ;;\n    -*|--*)\n      echo \"Unknown option $1\"\n      exit 1\n      ;;\n    *)\n      POSITIONAL_ARGS+=(\"$1\") # save positional arg\n      shift # past argument\n      ;;\n  esac\ndone\n\nset -- \"${POSITIONAL_ARGS[@]}\" # restore positional parameters\n\necho \"FILE EXTENSION  = ${EXTENSION}\"\necho \"SEARCH PATH     = ${SEARCHPATH}\"\necho \"DEFAULT         = ${DEFAULT}\"\necho \"Number files in SEARCH PATH with EXTENSION:\" $(ls -1 \"${SEARCHPATH}\"/*.\"${EXTENSION}\" | wc -l)\n\nif [[ -n $1 ]]; then\n    echo \"Last line of file specified as non-opt/last argument:\"\n    tail -1 \"$1\"\nfi\nEOF\n\nchmod +x /tmp/demo-space-separated.sh\n\n/tmp/demo-space-separated.sh -e conf -s /etc /etc/hosts\n'''\n\n\n\nOutput from copy-pasting the block above\n\n\n\n'''\nFILE EXTENSION  = conf\nSEARCH PATH     = /etc\nDEFAULT         =\nNumber files in SEARCH PATH with EXTENSION: 14\nLast line of file specified as non-opt/last argument:\n#93.184.216.34    example.com\n'''\n\n\n\nUsage\n\n\n\n'''\ndemo-space-separated.sh -e conf -s /etc /etc/hosts\n'''\n\n\n\n\n\nBash Equals-Separated (e.g., \n--option=argument\n)\n\n\n\n'''\ncat >/tmp/demo-equals-separated.sh <<'EOF'\n#!/bin/bash\n\nfor i in \"$@\"; do\n  case $i in\n    -e=*|--extension=*)\n      EXTENSION=\"${i#*=}\"\n      shift # past argument=value\n      ;;\n    -s=*|--searchpath=*)\n      SEARCHPATH=\"${i#*=}\"\n      shift # past argument=value\n      ;;\n    --default)\n      DEFAULT=YES\n      shift # past argument with no value\n      ;;\n    -*|--*)\n      echo \"Unknown option $i\"\n      exit 1\n      ;;\n    *)\n      ;;\n  esac\ndone\n\necho \"FILE EXTENSION  = ${EXTENSION}\"\necho \"SEARCH PATH     = ${SEARCHPATH}\"\necho \"DEFAULT         = ${DEFAULT}\"\necho \"Number files in SEARCH PATH with EXTENSION:\" $(ls -1 \"${SEARCHPATH}\"/*.\"${EXTENSION}\" | wc -l)\n\nif [[ -n $1 ]]; then\n    echo \"Last line of file specified as non-opt/last argument:\"\n    tail -1 $1\nfi\nEOF\n\nchmod +x /tmp/demo-equals-separated.sh\n\n/tmp/demo-equals-separated.sh -e=conf -s=/etc /etc/hosts\n'''\n\n\n\nOutput from copy-pasting the block above\n\n\n\n'''\nFILE EXTENSION  = conf\nSEARCH PATH     = /etc\nDEFAULT         =\nNumber files in SEARCH PATH with EXTENSION: 14\nLast line of file specified as non-opt/last argument:\n#93.184.216.34    example.com\n'''\n\n\n\nUsage\n\n\n\n'''\ndemo-equals-separated.sh -e=conf -s=/etc /etc/hosts\n'''\n\n\n\n\n\nTo better understand \n${i#*=}\n search for \"Substring Removal\" in \nthis guide\n. It is functionally equivalent to \n`sed 's/[^=]*=//' <<< \"$i\"`\n which calls a needless subprocess or \n`echo \"$i\" | sed 's/[^=]*=//'`\n which calls \ntwo\n needless subprocesses.\n\n\n\n\nUsing bash with getopt[s]\n\n\ngetopt(1) limitations (older, relatively-recent \ngetopt\n versions):\n\n\n\n\ncan't handle arguments that are empty strings\n\n\ncan't handle arguments with embedded whitespace\n\n\n\n\nMore recent \ngetopt\n versions don't have these limitations. For more information, see these \ndocs\n.\n\n\n\n\nPOSIX getopts\n\n\nAdditionally, the POSIX shell and others offer \ngetopts\n which doen't have these limitations. I've included a simplistic \ngetopts\n example.\n\n\n\n'''\ncat >/tmp/demo-getopts.sh <<'EOF'\n#!/bin/sh\n\n# A POSIX variable\nOPTIND=1         # Reset in case getopts has been used previously in the shell.\n\n# Initialize our own variables:\noutput_file=\"\"\nverbose=0\n\nwhile getopts \"h?vf:\" opt; do\n  case \"$opt\" in\n    h|\\?)\n      show_help\n      exit 0\n      ;;\n    v)  verbose=1\n      ;;\n    f)  output_file=$OPTARG\n      ;;\n  esac\ndone\n\nshift $((OPTIND-1))\n\n[ \"${1:-}\" = \"--\" ] && shift\n\necho \"verbose=$verbose, output_file='$output_file', Leftovers: $@\"\nEOF\n\nchmod +x /tmp/demo-getopts.sh\n\n/tmp/demo-getopts.sh -vf /etc/hosts foo bar\n'''\n\n\n\nOutput from copy-pasting the block above\n\n\n\n'''\nverbose=1, output_file='/etc/hosts', Leftovers: foo bar\n'''\n\n\n\nUsage\n\n\n\n'''\ndemo-getopts.sh -vf /etc/hosts foo bar\n'''\n\n\n\nThe advantages of \ngetopts\n are:\n\n\n\n\nIt's more portable, and will work in other shells like \ndash\n.\n\n\nIt can handle multiple single options like \n-vf filename\n in the typical Unix way, automatically.\n\n\n\n\nThe disadvantage of \ngetopts\n is that it can only handle short options (\n-h\n, not \n--help\n) without additional code.\n\n\nThere is a \ngetopts tutorial\n which explains what all of the syntax and variables mean.  In bash, there is also \nhelp getopts\n, which might be informative."
  },
  {
    "instruction": "Do a \"git export\" (like \"svn export\")?",
    "response": "Probably the simplest way to achieve this is with \ngit archive\n. If you really need just the expanded tree you can do something like this.\n\n\n\n'''\ngit archive master | tar -x -C /somewhere/else\n'''\n\n\n\nMost of the time that I need to 'export' something from git, I want a compressed archive in any case so I do something like this.\n\n\n\n'''\ngit archive master | bzip2 >source-tree.tar.bz2\n'''\n\n\n\nZIP archive:\n\n\n\n'''\ngit archive --format zip --output /full/path/to/zipfile.zip master\n'''\n\n\n\ngit help archive\n for more details, it's quite flexible.\n\n\n\n\nBe aware that even though the archive will not contain the .git directory, it will, however, contain other hidden git-specific files like .gitignore, .gitattributes, etc. If you don't want them in the archive, make sure you use the export-ignore attribute in a .gitattributes file and commit this before doing your archive. \nRead more...\n\n\n\n\nNote: If you are interested in exporting the index, the command is\n\n\n\n'''\ngit checkout-index -a -f --prefix=/destination/path/\n'''\n\n\n\n(See \nGreg's answer\n for more details)\n\n\n\n\nHere's a real-world example using libchrony on Linux:\n\n\n\n'''\nmkdir $HOME/dev\ncd $HOME/dev\npushd /tmp\ngit clone https://gitlab.com/chrony/libchrony.git\ncd libchrony\nBRANCH=$(git rev-parse --abbrev-ref HEAD)\ngit archive -o ../libchrony.zip --prefix=\"libchrony/\" $BRANCH\npopd\nunzip /tmp/libchrony.zip\n'''\n\n\n\nThose commands produce a zip file and extract it into \n$HOME/dev/libchrony\n. We can peek into the archive using:\n\n\n\n'''\n$ unzip -v /tmp/libchrony\nArchive:  /tmp/libchrony.zip\ne0a3807f770b56f6b0e9833254baa7c4fc13564b\n Length   Method    Size  Cmpr    Date    Time   CRC-32   Name\n--------  ------  ------- ---- ---------- ----- --------  ----\n       0  Stored        0   0% 2023-07-20 09:37 00000000  libchrony/\n      49  Defl:N       47   4% 2023-07-20 09:37 37c3f2e2  libchrony/.gitignore\n   26530  Defl:N     9350  65% 2023-07-20 09:37 5622583e  libchrony/COPYING\n     961  Defl:N      467  51% 2023-07-20 09:37 da9221e3  libchrony/Makefile\n     475  Defl:N      304  36% 2023-07-20 09:37 cae27f70  libchrony/README.adoc\n    3313  Defl:N     1119  66% 2023-07-20 09:37 37eb110f  libchrony/chrony.h\n    7673  Defl:N     2261  71% 2023-07-20 09:37 5d455a52  libchrony/client.c\n    6190  Defl:N     2093  66% 2023-07-20 09:37 7ea9d81b  libchrony/example-reports.c\n   16348  Defl:N     3855  76% 2023-07-20 09:37 e82f5fe3  libchrony/message.c\n    2946  Defl:N     1099  63% 2023-07-20 09:37 945ee82b  libchrony/message.h\n--------          -------  ---                            -------\n   64485            20595  68%                            10 files\n'''"
  },
  {
    "instruction": "How can I git stash a specific file?",
    "response": "Since git 2.13, there is a command to save a specific path to the stash: \ngit stash push <path>\n. For example:\n\n\n\n'''\ngit stash push -m welcome_cart app/views/cart/welcome.thtml\n'''\n\n\n\n\n\nWith earlier versions:\n\n\nYou can do that using \ngit stash --patch\n (or \ngit stash -p\n) -- you'll enter interactive mode where you'll be presented with each hunk that was changed. Use \nn\n to skip the files that you don't want to stash, \ny\n when you encounter the one that you want to stash, and \nq\n to quit and leave the remaining hunks unstashed.  \na\n will stash the shown hunk and the rest of the hunks in that file.\n\n\nNot the most user-friendly approach, but it gets the work done if you really need it."
  },
  {
    "instruction": "Do I commit the package-lock.json file created by npm 5?",
    "response": "Yes, \npackage-lock.json\n is intended to be checked into source control. If you're using npm 5+, you may see this notice on the command line: \ncreated a lockfile as package-lock.json. You should commit this file.\n According to \nnpm help package-lock.json\n:\n\n\n\n\npackage-lock.json\n is automatically generated for any operations where npm\nmodifies either the \nnode_modules\n tree, or \npackage.json\n. It describes the\nexact tree that was generated, such that subsequent installs are able to\ngenerate identical trees, regardless of intermediate dependency updates.\n\n\nThis file is intended to be committed into source repositories\n, and serves\nvarious purposes:\n\n\n\n\nDescribe a single representation of a dependency tree such that teammates, deployments, and continuous integration are guaranteed to install exactly the same dependencies.\n\n\n\n\nProvide a facility for users to \"time-travel\" to previous states of \nnode_modules\n without having to commit the directory itself.\n\n\n\n\nTo facilitate greater visibility of tree changes through readable source control diffs.\n\n\n\n\nAnd optimize the installation process by allowing npm to skip repeated metadata resolutions for previously-installed packages.\n\n\n\n\n\n\nOne key detail about \npackage-lock.json\n is that it cannot be published, and it\nwill be ignored if found in any place other than the toplevel package. It shares\na format with npm-shrinkwrap.json, which is essentially the same file, but\nallows publication. This is not recommended unless deploying a CLI tool or\notherwise using the publication process for producing production packages.\n\n\nIf both \npackage-lock.json\n and \nnpm-shrinkwrap.json\n are present in the root of\na package, \npackage-lock.json\n will be completely ignored."
  },
  {
    "instruction": "How do I set a variable to the output of a command in Bash?",
    "response": "In addition to backticks \n`command`\n, \ncommand substitution\n can be done with \n$(command)\n or \n\"$(command)\"\n, which I find easier to read, and allows for nesting.\n\n\n\n'''\nOUTPUT=\"$(ls -1)\"\necho \"${OUTPUT}\"\n\nMULTILINE=\"$(ls \\\n   -1)\"\necho \"${MULTILINE}\"\n'''\n\n\n\nQuoting (\n\"\n) does matter to preserve \nmulti-line variable values\n and it is safer to use with whitespace and special characters such as (\n*\n) and therefore advised; it is, however, optional on the right-hand side of an assignment when \nword splitting is not performed\n, so \nOUTPUT=$(ls -1)\n would work fine."
  },
  {
    "instruction": "How to check if a variable is set in Bash",
    "response": "(Usually) The right way\n\n\n\n'''\nif [ -z ${var+x} ]; then echo \"var is unset\"; else echo \"var is set to '$var'\"; fi\n'''\n\n\n\nwhere \n${var+x}\n is a \nparameter expansion\n which evaluates to nothing if \nvar\n is unset, and substitutes the string \nx\n otherwise.\n\n\nQuotes Digression\n\n\nQuotes can be omitted (so we can say \n${var+x}\n instead of \n\"${var+x}\"\n) because this syntax & usage guarantees this will only expand to something that does not require quotes (since it either expands to \nx\n (which contains no word breaks so it needs no quotes), or to nothing (which results in \n[ -z  ]\n, which conveniently evaluates to the same value (true) that \n[ -z \"\" ]\n does as well)).\n\n\nHowever, while quotes can be safely omitted, and it was not immediately obvious to all (it wasn't even apparent to \nthe first author of this quotes explanation\n who is also a major Bash coder), it would sometimes be better to write the solution with quotes as \n[ -z \"${var+x}\" ]\n, at the very small possible cost of an O(1) speed penalty.  The first author also added this as a comment next to the code using this solution giving the URL to this answer, which now also includes the explanation for why the quotes can be safely omitted.\n\n\n(Often) The wrong way\n\n\n\n'''\nif [ -z \"$var\" ]; then echo \"var is blank\"; else echo \"var is set to '$var'\"; fi\n'''\n\n\n\nThis is often wrong because it doesn't distinguish between a variable that is unset and a variable that is set to the empty string. That is to say, if \nvar=''\n, then the above solution will output \"var is blank\".\n\n\nThe distinction between unset and \"set to the empty string\" is essential in situations where the user has to specify an extension, or additional list of properties, and that not specifying them defaults to a non-empty value, whereas specifying the empty string should make the script use an empty extension or list of additional properties.\n\n\nThe distinction may not be essential in every scenario though. In those cases  \n[ -z \"$var\" ]\n will be just fine."
  },
  {
    "instruction": "How do you stash an untracked file?",
    "response": "To stash your working directory including untracked files (especially those that are in the \n.gitignore\n) then you probably want to use this cmd:\n\n\n\n'''\ngit stash --include-untracked\n'''\n\n\n\nAlternatively, you can use the shorthand \n-u\n instead of \n--include-untracked\n, or simply \ngit stash --all\n (see warning below for this one) which stashes all files, including \nuntracked\n and \nignored\n files. This behaviour changed in 2018, so make sure your git is up to date.\n\n\n\n\nWarning: there seems to be (or have been) situations in which contents of ignored directories could be deleted permanently. \nSee this archived website for more information\n."
  },
  {
    "instruction": "Throw away local commits in Git",
    "response": "If your excess commits are only visible to you, you can just do \n\ngit reset --hard origin/<branch_name>\n \nto move back to where the origin is. This will reset the state of the repository to the previous commit, and it will discard all local changes.\n\n\nDoing a \ngit revert\n makes \nnew\n commits to remove \nold\n commits in a way that keeps everyone's history sane."
  },
  {
    "instruction": "How do I fetch all Git branches?",
    "response": "TL;DR answer\n\n\n\n'''\ngit branch -r \\\n  | grep -v '\\->' \\\n  | sed \"s,\\x1B\\[[0-9;]*[a-zA-Z],,g\" \\\n  | while read remote; do \\\n      git branch --track \"${remote#origin/}\" \"$remote\"; \\\n    done\ngit fetch --all\ngit pull --all\n'''\n\n\n\n(\ngrep -v\n matches the inverse of given string; \nsed\n removes control sequences: \n\\x1B\n matches \nesc\n)\n\n\n(It seems that pull fetches all branches from all remotes, but I always fetch first just to be sure.)\n\n\nRun the first command only if there are remote branches on the server that aren't tracked by your local branches.\n\n\nComplete answer\n\n\nYou can fetch all branches from all remotes like this:\n\n\n\n'''\ngit fetch --all\n'''\n\n\n\nIt's basically a \npower move\n.\n\n\nfetch\n updates local copies of remote branches so this is always safe for your local branches \nBUT\n:\n\n\n\n\nfetch\n will not \nupdate\n local branches (which \ntrack\n remote branches); if you want to update your local branches you still need to pull every branch.\n\n\n\n\nfetch\n will not \ncreate\n local branches (which \ntrack\n remote branches), you have to do this manually. If you want to list all remote branches:\n\ngit branch -a\n\n\n\n\n\n\nTo \nupdate\n local branches which track remote branches:\n\n\n\n'''\ngit pull --all\n'''\n\n\n\nHowever, this can be still insufficient. It will work only for your local branches which track remote branches. To track all remote branches execute this oneliner \nBEFORE\n \ngit pull --all\n:\n\n\n\n'''\ngit branch -r | grep -v '\\->' | sed \"s,\\x1B\\[[0-9;]*[a-zA-Z],,g\" | while read remote; do git branch --track \"${remote#origin/}\" \"$remote\"; done\n'''\n\n\n\nP.S. AFAIK \ngit fetch --all\n and \ngit remote update\n are equivalent.\n\n\n\n\n\n\nKamil Szot's \ncomment\n, which folks have found useful.\n\n\n\n\nI had to use:\n\n\n\n'''\nfor remote in `git branch -r`; do git branch --track ${remote#origin/} $remote; done\n'''\n\n\n\nbecause your code created local branches named \norigin/branchname\n and\nI was getting \"refname 'origin/branchname' is ambiguous whenever I\nreferred to it."
  },
  {
    "instruction": "How can I see the changes in a Git commit?",
    "response": "To see the diff for a particular \nCOMMIT\n hash, where \nCOMMIT\n is the hash of the commit:\n\n\ngit diff COMMIT~ COMMIT\n will show you the difference between that \nCOMMIT\n's ancestor and the \nCOMMIT\n. See the man pages for \ngit diff\n for details about the command and \ngitrevisions\n about the \n~\n notation and its friends.\n\n\nAlternatively, \ngit show COMMIT\n will do something very similar. (The commit's data, including its diff - but not for merge commits.) See the \ngit show manpage\n.\n\n\n(also \ngit diff COMMIT\n will show you the difference between that \nCOMMIT\n and the head.)"
  },
  {
    "instruction": "Loop through an array of strings in Bash?",
    "response": "You can use it like this:\n\n\n\n'''\n## declare an array variable\ndeclare -a arr=(\"element1\" \"element2\" \"element3\")\n\n## now loop through the above array\nfor i in \"${arr[@]}\"\ndo\n   echo \"$i\"\n   # or do whatever with individual element of the array\ndone\n\n# You can access them using echo \"${arr[0]}\", \"${arr[1]}\" also\n'''\n\n\n\nAlso works for multi-line array declaration\n\n\n\n'''\ndeclare -a arr=(\"element1\" \n                \"element2\" \"element3\"\n                \"element4\"\n                )\n'''"
  },
  {
    "instruction": "Showing which files have changed between two revisions",
    "response": "To compare the current branch against \nmain\n branch:\n\n\n\n'''\n$ git diff --name-status main\n'''\n\n\n\nTo compare any two branches:\n\n\n\n'''\n$ git diff --name-status firstbranch..yourBranchName\n'''\n\n\n\nThere are more options to \ngit diff\n in the \nofficial documentation\n (and specifically the \n--name-status\n option)."
  },
  {
    "instruction": "Remove file from latest commit",
    "response": "I think other answers here are wrong, because this is a question of moving the mistakenly committed files back to the staging area from the previous commit, without cancelling the changes done to them. This can be done like Paritosh Singh suggested:\n\n\n\n'''\ngit reset --soft HEAD^\n'''\n\n\n\nor\n\n\n\n'''\ngit reset --soft HEAD~1\n'''\n\n\n\nThen reset the unwanted files in order to leave them out from the commit (the old way):\n\n\n\n'''\ngit reset HEAD path/to/unwanted_file\n'''\n\n\n\nNote, that since Git \n2.23.0\n one can (\nthe new way\n):\n\n\n\n'''\ngit restore --staged path/to/unwanted_file\n'''\n\n\n\nNow commit again, you can even re-use the same commit message:\n\n\n\n'''\ngit commit -c ORIG_HEAD\n'''\n\n\n\nEDIT\n: The easiest way to do this is to use e.g. \ngit gui\n. Just select \nCommit => Amend Last Commit\n and simply uncheck the desired file from the commit and click \nCommit\n."
  },
  {
    "instruction": "How to list unpushed Git commits (local but not on origin)",
    "response": "This gives a log of all commits between origin/master and HEAD:\n\n\n\n'''\ngit log origin/master..HEAD\n'''\n\n\n\nWhen HEAD is on the master branch, this gives a log of unpushed commits.\n\n\n\n\nSimilarly, to view the diff:\n\n\n\n'''\ngit diff origin/master..HEAD\n'''"
  },
  {
    "instruction": "Remove tracking branches no longer on remote",
    "response": "git remote prune origin\n prunes tracking branches not on the remote.\n\n\ngit branch --merged\n lists branches that have been merged into the current branch.\n\n\nxargs git branch -d\n deletes branches listed on standard input.\n\n\nBe careful deleting branches listed by \ngit branch --merged\n. The list could include \nmaster\n or other branches you'd prefer not to delete.\n\n\nTo give yourself the opportunity to edit the list before deleting branches, you could do the following in one line:\n\n\n\n'''\ngit branch --merged >/tmp/merged-branches && \\\n  vi /tmp/merged-branches && xargs git branch -d </tmp/merged-branches\n'''"
  },
  {
    "instruction": "How do you merge two Git repositories?",
    "response": "A single branch of another repository can be easily placed under a subdirectory retaining its history. For example:\n\n\n\n'''\ngit subtree add --prefix=rails git://github.com/rails/rails.git master\n'''\n\n\n\nThis will appear as a single commit where all files of Rails master branch are added into \"rails\" directory.\nHowever the commit's title contains a reference to the old history tree:\n\n\n\n\nAdd 'rails/' from commit \n<rev>\n\n\n\n\nWhere \n<rev>\n is a SHA-1 commit hash. You can still see the history, blame some changes.\n\n\n\n'''\ngit log <rev>\ngit blame <rev> -- README.md\n'''\n\n\n\nNote that you can't see the directory prefix from here since this is an actual old branch left intact.\nYou should treat this like a usual file move commit: you will need an extra jump when reaching it.\n\n\n\n'''\n# finishes with all files added at once commit\ngit log rails/README.md\n\n# then continue from original tree\ngit log <rev> -- README.md\n'''\n\n\n\nThere are more complex solutions like doing this manually or rewriting the history as described in other answers.\n\n\nThe git-subtree command is a part of official git-contrib, some packet managers install it by default (OS X Homebrew).\nBut you might have to install it by yourself in addition to git."
  },
  {
    "instruction": "How to compare files from two different branches",
    "response": "git diff\n can show you the difference between two commits:\n\n\n\n'''\ngit diff mybranch master -- myfile.cs\n'''\n\n\n\nOr, equivalently:\n\n\n\n'''\ngit diff mybranch..master -- myfile.cs\n'''\n\n\n\nNote you must specify the relative path to the file. So if the file were in the src directory, you'd say \nsrc/myfile.cs\n instead of \nmyfile.cs\n.\n\n\nUsing the latter syntax, if either side is \nHEAD\n it may be omitted (e.g., \nmaster..\n compares \nmaster\n to \nHEAD\n).\n\n\nYou may also be interested in \nmybranch...master\n (from \ngit diff\n documentation\n):\n\n\n\n\nThis form is to view the changes on the branch containing and up to the second \n<commit>\n, starting at a common ancestor of both \n<commit>\n. \ngit diff A...B\n is equivalent to \ngit diff $(git-merge-base A B) B\n.\n\n\n\n\nIn other words, this will give a diff of changes in \nmaster\n since it diverged from \nmybranch\n (but without new changes since then in \nmybranch\n).\n\n\n\n\nIn all cases, the \n--\n separator before the file name indicates the end of command line flags (mind the space between the separator and the filename). This is optional unless Git will get confused if the argument refers to a commit or a file, but including it is not a bad habit to get into. See \nDietrich Epp's answer to \nMeaning of Git checkout double dashes\n for a few examples.\n\n\n\n\nThe same arguments can be passed to \ngit difftool\n if you have one configured."
  },
  {
    "instruction": "How do I iterate over a range of numbers defined by variables in Bash?",
    "response": "'''\nfor i in $(seq 1 $END); do echo $i; done\n'''\n\n\n\nedit: I prefer \nseq\n over the other methods because I can actually remember it ;)"
  },
  {
    "instruction": "How to reload .bashrc settings without logging out and back in again?",
    "response": "You can enter the long form command:\n\n\n\n'''\nsource ~/.bashrc\n'''\n\n\n\nor you can use the shorter version of the command:\n\n\n\n'''\n. ~/.bashrc\n'''"
  },
  {
    "instruction": "How do I recursively grep all directories and subdirectories?",
    "response": "'''\ngrep -r \"texthere\" .\n'''\n\n\n\nThe first parameter represents the regular expression to search for, while the second one represents the directory that should be searched. In this case, \n.\n means the current directory.\n\n\nNote: This works for GNU grep, and on some platforms like Solaris you must specifically use GNU grep as opposed to legacy implementation.  For Solaris this is the \nggrep\n command."
  },
  {
    "instruction": "How can I delete all of my Git stashes at once?",
    "response": "The following command deletes all your stashes:\n\n\n\n'''\ngit stash clear\n'''\n\n\n\nFrom the \ngit documentation\n:\n\n\n\n\nclear\n\n\nRemove all the stashed states.\n\n\nIMPORTANT WARNING:\n Those states will then be subject to pruning, and may be impossible to recover (...)."
  },
  {
    "instruction": "Can I delete (or undo) a git commit but keep the changes?",
    "response": "It's as simple as this:\n\n\n\n'''\ngit reset HEAD^\n'''\n\n\n\nNote: some shells treat \n^\n as a special character (for example some Windows shells or \nZSH with globbing enabled\n), so you may have to quote \n\"HEAD^\"\n or use \nHEAD~1\n in those cases.\n\n\ngit reset\n without a \n--hard\n or \n--soft\n moves your \nHEAD\n to point to the specified commit, without changing any files. \nHEAD^\n refers to the (first) parent commit of your current commit, which in your case is the commit before the temporary one.\n\n\nNote that another option is to carry on as normal, and then at the next commit point instead run:\n\n\n\n'''\ngit commit --amend [-m … etc]\n'''\n\n\n\nwhich will instead \nedit\n the most recent commit, having the same effect as above.\n\n\nNote that this (as with nearly every git answer) can cause problems if you've already pushed the bad commit to a place where someone else may have pulled it from. Try to avoid that"
  },
  {
    "instruction": "How do I fix a Git detached head?",
    "response": "Detached head means you are no longer on a branch, you have checked out a single commit in the history (in this case the commit previous to HEAD, i.e. HEAD^).\n\n\nIf you want to \nkeep\n your changes associated with the detached HEAD\n\n\n\n\nRun \ngit branch tmp\n - this will save your changes in a new branch called \ntmp\n.\n\n\nRun \ngit checkout master\n\n\nIf you would like to incorporate the changes you made into \nmaster\n, run \ngit merge tmp\n from the \nmaster\n branch. You should be on the \nmaster\n branch after running \ngit checkout master\n.\n\n\n\n\nIf you want to \ndelete\n your changes associated with the detached HEAD\n\n\nYou only need to checkout the branch you were on, e.g.\n\n\n\n'''\ngit checkout master\n'''\n\n\n\nNext time you have changed a file and want to restore it to the state it is in the index, don't delete the file first, just do\n\n\n\n'''\ngit checkout -- path/to/foo\n'''\n\n\n\nThis will restore the file foo to the state it is in the index."
  },
  {
    "instruction": "Looping through the content of a file in Bash",
    "response": "One way to do it is:\n\n\n\n'''\nwhile read p; do\n  echo \"$p\"\ndone <peptides.txt\n'''\n\n\n\nAs pointed out in the comments, this has the side effects of trimming leading whitespace, interpreting backslash sequences, and skipping the last line if it's missing a terminating linefeed. If these are concerns, you can do:\n\n\n\n'''\nwhile IFS=\"\" read -r p || [ -n \"$p\" ]\ndo\n  printf '%s\\n' \"$p\"\ndone < peptides.txt\n'''\n\n\n\n\n\nExceptionally, if the \nloop body may read from standard input\n, you can open the file using a different file descriptor:\n\n\n\n'''\nwhile read -u 10 p; do\n  ...\ndone 10<peptides.txt\n'''\n\n\n\nHere, 10 is just an arbitrary number (different from 0, 1, 2)."
  },
  {
    "instruction": "How to replace master branch in Git, entirely, from another branch?",
    "response": "You should be able to use the “ours” merge strategy to overwrite master with seotweaks like this:\n\n\n\n'''\ngit checkout master\ngit pull\ngit checkout seotweaks\ngit merge -s ours master\ngit checkout master\ngit merge seotweaks\n'''\n\n\n\nThe first two steps are a useful precaution to ensure your local copy of master is up-to-date. The result should be that your master is now essentially seotweaks.\n\n\n(\n-s ours\n is short for \n--strategy=ours\n)\n\n\nFrom \nthe docs\n about the 'ours' strategy:\n\n\n\n\nThis resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the recursive merge strategy.\n\n\n\n\nUpdate from comments: If you get fatal: \nrefusing to merge unrelated histories\n, then change the fourth line to this: \ngit merge --allow-unrelated-histories -s ours master"
  },
  {
    "instruction": "How does Git handle symbolic links?",
    "response": "From \nlinux symlink manual\n (assuming you are in Linux):\n\n\n\n\nA symbolic link is a special type of file whose contents are a string that is the pathname of another file, the file to which the link refers.  (The contents of a symbolic link can be read using readlink(2).)\n\n\n\n\nSo a symbolic link is just another file, no different than a \nREADME.md\n or a \nMakefile\n. Git just stores the contents of the link (i.e. the aforementioned path of the file system object that it links to) in a 'blob' just like it would for any other file. It then stores the name, mode and type (including the fact that it is a symlink) in the tree object that represents its containing directory.\n\n\nWhen you checkout a tree containing the link, it restores the object as a symlink regardless of whether the target file system object exists or not.\n\n\nIf you delete the file that the symlink references it doesn't affect the Git-controlled symlink in any way. You will have a dangling reference. It is up to the user to either remove or change the link to point to something valid if needed."
  },
  {
    "instruction": "Download a specific tag with Git",
    "response": "'''\n$ git clone\n'''\n\n\n\nwill give you the whole repository.\n\n\nAfter the clone, you can list the tags with \n$ git tag -l\n and then checkout a specific tag:\n\n\n\n'''\n$ git checkout tags/<tag_name>\n'''\n\n\n\nEven better, checkout and create a branch (otherwise you will be on a branch named after the revision number of tag):\n\n\n\n'''\n$ git checkout tags/<tag_name> -b <branch_name>\n'''"
  },
  {
    "instruction": "How do I clone a subdirectory only of a Git repository?",
    "response": "As of Git 2.19, this is finally possible, as can be seen in \nthis answer\n.\n\n\nConsider upvoting that answer.\n\n\nNote: in Git 2.19, only client-side support is implemented, server-side support is still missing, so it only works when cloning local repositories. Also note that large Git hosters, e.g. GitHub, don't actually use the Git server, they use their own implementation, so even if support shows up in the Git server, it does not automatically mean that it works on Git hosters. (On the other hand, since they don't use the Git server, they could implement it faster in their own implementations before it shows up in Git server.)\n\n\n\n\nNo, that's not possible in Git.\n\n\nImplementing something like this in Git would be a substantial effort and it would mean that the integrity of the client-side repository could no longer be guaranteed. If you are interested, search for discussions on \"sparse clone\" and \"sparse fetch\" on the Git mailing list.\n\n\nIn general, the consensus in the Git community is that if you have several directories that are always checked out independently, then these are really two different projects and should live in two different repositories. You can glue them back together using \nGit Submodules\n."
  },
  {
    "instruction": "Is there a way to cache https credentials for pushing commits?",
    "response": "Since Git 1.7.9 (released 2012), there is a neat mechanism in Git to avoid having to type your password all the time for HTTP / HTTPS, called \ncredential helpers\n.\n\n\nYou can just use one of the following credential helpers:\n\n\n\n'''\ngit config --global credential.helper cache\n'''\n\n\n\nThe \ncredential.helper cache value\n tells Git to keep your password cached in memory for a particular amount of \nminutes\n. The default is 15 minutes, you can set a longer timeout with:\n\n\n\n'''\n# Cache for 1 hour\ngit config --global credential.helper \"cache --timeout=3600\"\n\n# Cache for 1 day\ngit config --global credential.helper \"cache --timeout=86400\"\n\n# Cache for 1 week\ngit config --global credential.helper \"cache --timeout=604800\"\n'''\n\n\n\nYou can also store your credentials permanently if so desired, see the other answers below.\n\n\nGitHub's help \nalso suggests\n that if you're on Mac OS X and used \nHomebrew\n to install Git, you can use the native Mac OS X keystore with:\n\n\n\n'''\ngit config --global credential.helper osxkeychain\n'''\n\n\n\nFor Windows\n, there is a helper called \nGit Credential Manager for Windows\n or \nwincred in msysgit\n.\n\n\n\n'''\ngit config --global credential.helper wincred # obsolete\n'''\n\n\n\nWith \nGit for Windows 2.7.3+\n (March 2016):\n\n\n\n'''\ngit config --global credential.helper manager\n'''\n\n\n\nFor Linux\n, you would use (in 2011) \ngnome-keyring\n(or other keyring implementation such as KWallet).\n\n\nNowadays (2020), that would be (on Linux)\n\n\nFedora\n\n\n\n'''\nsudo dnf install git-credential-libsecret\ngit config --global credential.helper /usr/libexec/git-core/git-credential-libsecret\n'''\n\n\n\nUbuntu\n\n\n\n'''\nsudo apt-get install libsecret-1-0 libsecret-1-dev\ncd /usr/share/doc/git/contrib/credential/libsecret\nsudo make\ngit config --global credential.helper /usr/share/doc/git/contrib/credential/libsecret/git-credential-libsecret\n'''"
  },
  {
    "instruction": "How to get just one file from another branch",
    "response": "'''\ngit checkout main                 # first get back to main\ngit checkout experiment -- app.js # then copy the version of app.js \n                                  # from branch \"experiment\"\n'''\n\n\n\nSee also \nUndo working copy modifications of one file in Git\n.\n\n\n\n\nUpdate August 2019, Git 2.23\n\n\nWith the new \ngit switch\n and \ngit restore\n commands, that would be:\n\n\n\n'''\ngit switch main\ngit restore --source experiment -- app.js\n'''\n\n\n\nBy default, only the working tree is restored.\n\nIf you want to update the index as well (meaning restore the file content, \nand\n add it to the index in one command):\n\n\n\n'''\ngit restore --source experiment --staged --worktree -- app.js\n# shorter:\ngit restore -s experiment -SW -- app.js\n'''\n\n\n\n\n\nAs \nJakub Narębski\n mentions in the comments:\n\n\n\n'''\ngit show experiment:path/to/app.js > path/to/app.js\n'''\n\n\n\nworks too, except that, as detailed in the SO question \"\nHow to retrieve a single file from specific revision in Git?\n\", you need to use the full path from the root directory of the repo.\n\nHence the path/to/app.js used by Jakub in his example.\n\n\nAs \nFrosty\n mentions in the comment:\n\n\n\n\nyou will only get the most recent state of app.js\n\n\n\n\nBut, for \ngit checkout\n or \ngit show\n, you can actually reference any revision you want, as illustrated in the SO question \"\ngit checkout revision of a file in git gui\n\":\n\n\n\n'''\n$ git show $REVISION:$FILENAME\n$ git checkout $REVISION -- $FILENAME\n'''\n\n\n\nwould be the same is $FILENAME is a \nfull path\n of a versioned file.\n\n\n$REVISION\n can be as shown in \ngit rev-parse\n:\n\n\n\n'''\nexperiment@{yesterday}:app.js # app.js as it was yesterday \nexperiment^:app.js            # app.js on the first commit parent\nexperiment@{2}:app.js         # app.js two commits ago\n'''\n\n\n\nand so on.\n\n\nschmijos\n adds \nin the comments\n:\n\n\n\n\nyou also can do this from a stash:\n\n\n\n'''\ngit checkout stash -- app.js\n'''\n\n\n\nThis is very useful if you're working on two branches and don't want to commit."
  },
  {
    "instruction": "Resolve Git merge conflicts in favor of their changes during a pull",
    "response": "If you're already in conflicted state, and do not want to checkout path one by one. You may try\n\n\n\n'''\ngit merge --abort\ngit pull -X theirs\n'''"
  },
  {
    "instruction": "Make the current Git branch a master branch",
    "response": "The problem with the other two answers is that the new master doesn't have the old master as an ancestor, so when you push it, everyone else will get messed up. This is what you want to do:\n\n\n\n'''\ngit checkout better_branch          # This is the branch whose commits you want to keep\ngit merge --strategy=ours master    # keep the content of this branch, but record a merge\ngit checkout master                 # You want to **lose** all changes on this branch\ngit merge better_branch             # fast-forward master up to the merge\n'''\n\n\n\nIn older versions of \ngit\n, if you want your history to be a little clearer, I'd recommend adding some information to the merge commit message to make it clear what you've done. Change the second line to:\n\n\n\n'''\ngit merge --strategy=ours --no-commit master\ngit commit          # add information to the template merge message\n'''\n\n\n\nIn newer versions of git, \ngit\n will automatically open the git message editor for you. (Or you can use \ngit mere --strategy=ours master -m \"Keeping better_branch\"\n)"
  },
  {
    "instruction": "Undo working copy modifications of one file in Git",
    "response": "You can use\n\n\n\n'''\ngit checkout -- file\n'''\n\n\n\nYou can do it without the \n--\n (as suggested by nimrodm), but if the filename looks like a branch or tag (or other revision identifier), it may get confused, so using \n--\n is best.\n\n\nYou can also check out a particular version of a file:\n\n\n\n'''\ngit checkout v1.2.3 -- file         # tag v1.2.3\ngit checkout stable -- file         # stable branch\ngit checkout origin/master -- file  # upstream master\ngit checkout HEAD -- file           # the version from the most recent commit\ngit checkout HEAD^ -- file          # the version before the most recent commit\n'''\n\n\n\nMore details included based on comments\n\n\nFirst check the the commits of the file\n\n\n\n'''\ngit log -- <filename>\n'''\n\n\n\nThen you can run this\n\n\n\n'''\ngit checkout <sha-reference> -- filename\n'''\n\n\n\nwhere the sha-reference is a reference to the sha of a commit, in any form (branch, tag, parent, etc."
  },
  {
    "instruction": "How to stop tracking and ignore changes to a file in Git?",
    "response": "Just calling \ngit rm --cached\n on each of the files you want to remove from revision control should be fine. As long as your local ignore patterns are correct you won't see these files included in the output of git status.\n\n\nNote that this solution removes the files from the repository, so all developers would need to maintain their own local (non-revision controlled) copies of the file\n\n\nTo prevent git from detecting changes in these files you should also use this command:\n\n\n\n'''\ngit update-index --assume-unchanged [path]\n'''\n\n\n\nWhat you probably want to do:\n (from below \n@Ryan Taylor answer\n)\n\n\n\n\n\n\nThis is to tell git you want your own independent version of the file or folder. For instance, you don't want to overwrite (or delete)\n  production/staging config files.\n\n\n\n\ngit update-index --skip-worktree <path-name>\n\n\n\n\nThe full answer is here in this URL: \nhttp://source.kohlerville.com/2009/02/untrack-files-in-git/"
  },
  {
    "instruction": "How can I count all the lines of code in a directory recursively?",
    "response": "Try:\n\n\n\n'''\nfind . -name '*.php' | xargs wc -l\n'''\n\n\n\nor (when file names include special characters such as spaces)\n\n\n\n'''\nfind . -name '*.php' | sed 's/.*/\"&\"/' | xargs  wc -l\n'''\n\n\n\nThe SLOCCount tool\n may help as well.\n\n\nIt will give an accurate source lines of code count for whatever\nhierarchy you point it at, as well as some additional stats.\n\n\nSorted output:\n\n\nfind . -name '*.php' | xargs wc -l | sort -nr"
  },
  {
    "instruction": "How can I remove a commit on GitHub?",
    "response": "Note:\n please see an alternative to \ngit rebase -i\n in the comments below—\n\n\ngit reset --soft HEAD^\n\n\n\n\nFirst, remove the commit on your local repository. You can do this using \ngit rebase -i\n. For example, if it's your last commit, you can do \ngit rebase -i HEAD~2\n and delete the second line within the editor window that pops up.\n\n\nThen, force push to GitHub by using \ngit push origin +branchName --force\n\n\nSee \nGit Magic Chapter 5: Lessons of History - And Then Some\n for more information (i.e. if you want to remove older commits).\n\n\nOh, and if your working tree is dirty, you have to do a \ngit stash\n first, and then a \ngit stash apply\n after."
  },
  {
    "instruction": "How can I get a list of Git branches, ordered by most recent commit?",
    "response": "Use the \n--sort=-committerdate\n option of \ngit for-each-ref\n;\n\n\nAlso available \nsince Git 2.7.0\n for \ngit branch\n:\n\n\nBasic Usage:\n\n\n\n'''\ngit for-each-ref --sort=-committerdate refs/heads/\n\n# Or using git branch (since version 2.7.0)\ngit branch --sort=-committerdate  # DESC\ngit branch --sort=committerdate  # ASC\n'''\n\n\n\nResult:\n\n\n\n\nAdvanced Usage:\n\n\n\n'''\ngit for-each-ref --sort=committerdate refs/heads/ --format='%(HEAD) %(align:35)%(color:yellow)%(refname:short)%(color:reset)%(end) - %(color:red)%(objectname:short)%(color:reset) - %(align:40)%(contents:subject)%(end) - %(authorname) (%(color:green)%(committerdate:relative)%(color:reset))'\n'''\n\n\n\nResult:\n\n\n\n\nPro Usage (Unix):\n\n\nYou can put the following snippet in your \n~/.gitconfig\n. The recentb alias accepts two arguments:\n\n\n\n\nrefbranch\n: which branch the \nahead\n and \nbehind\n columns are calculated against. Default \nmaster\n\n\ncount\n: how many recent branches to show. Default \n20\n\n\n\n\n\n'''\n[alias]\n    # ATTENTION: All aliases prefixed with ! run in /bin/sh make sure you use sh syntax, not bash/zsh or whatever\n    recentb = \"!r() { refbranch=$1 count=$2; git for-each-ref --sort=-committerdate refs/heads --format='%(refname:short)|%(HEAD)%(color:yellow)%(refname:short)|%(color:bold green)%(committerdate:relative)|%(color:blue)%(subject)|%(color:magenta)%(authorname)%(color:reset)' --color=always --count=${count:-20} | while read line; do branch=$(echo \\\"$line\\\" | awk 'BEGIN { FS = \\\"|\\\" }; { print $1 }' | tr -d '*'); ahead=$(git rev-list --count \\\"${refbranch:-origin/master}..${branch}\\\"); behind=$(git rev-list --count \\\"${branch}..${refbranch:-origin/master}\\\"); colorline=$(echo \\\"$line\\\" | sed 's/^[^|]*|//'); echo \\\"$ahead|$behind|$colorline\\\" | awk -F'|' -vOFS='|' '{$5=substr($5,1,70)}1' ; done | ( echo \\\"ahead|behind|branch|lastcommit|message|author\\n\\\" && cat) | column -ts'|';}; r\"\n'''\n\n\n\nResult:"
  },
  {
    "instruction": "How to redirect and append both standard output and standard error to a file with Bash",
    "response": "'''\ncmd >>file.txt 2>&1\n'''\n\n\n\nBash executes the redirects from left to right as follows:\n\n\n\n\n>>file.txt\n: Open \nfile.txt\n in append mode and redirect \nstdout\n there.\n\n\n2>&1\n: Redirect \nstderr\n to \n\"where \nstdout\n is currently going\"\n. In this case, that is a file opened in append mode. In other words, the \n&1\n reuses the file descriptor which \nstdout\n currently uses."
  },
  {
    "instruction": "How to avoid having to do \"git branch --set-upstream\", and instead default to automatically setup remote tracking?",
    "response": "Git v2.37.1 and above\n\n\nIf you are using the mentioned version or above you can use this new config entry to automatically setup remote tracking:\n\n\ngit config --global push.autoSetupRemote true\n\n\nAfter that, when you do \ngit push\n tracking is setup automatically. No need for \ngit push -u origin my_branch\n\n\n\n\nA shortcut, which doesn't depend on remembering the syntax for \ngit branch --set-upstream\n \n1\n is to do:\n\n\n\n'''\ngit push -u origin my_branch\n'''\n\n\n\n... the first time that you push that branch. Or, to push to the current branch from a branch of the same name (handy for an alias):\n\n\n\n'''\ngit push -u origin HEAD\n'''\n\n\n\nYou only need to use \n-u\n once, and that sets up the association between your branch and the one at \norigin\n in the same way as \ngit branch --set-upstream\n does.\n\n\nPersonally, I think it's a good thing to have to set up that association between your branch and one on the remote explicitly.  It's just a shame that the rules are \ndifferent for \ngit push\n and \ngit pull\n.\n\n\n\n\n1\n It may sound silly, but I very frequently forget to specify the current branch, assuming that's the default - it's not, and the results are most confusing.\n\n\nUpdate 2012-10-11\n: Apparently I'm not the only person who found it easy to get wrong! Thanks to \nVonC\n for pointing out that git 1.8.0 introduces the more obvious \ngit branch --set-upstream-to\n, which can be used as follows, if you're on the branch \nmy_branch\n:\n\n\n\n'''\ngit branch --set-upstream-to origin/my_branch\n'''\n\n\n\n... or with the short option:\n\n\n\n'''\ngit branch -u origin/my_branch\n'''\n\n\n\nThis change, and its reasoning, is described in \nthe release notes for git 1.8.0, release candidate 1\n:\n\n\n\n\nIt was tempting to say \ngit branch --set-upstream origin/master\n, but that tells Git to arrange the local branch \norigin/master\n to integrate with the currently checked out branch, which is highly unlikely to be what the user meant. The option is deprecated; use the new \n--set-upstream-to\n (with a short-and-sweet \n-u\n) option instead."
  },
  {
    "instruction": "How do I undo 'git reset'?",
    "response": "Short answer:\n\n\n\n'''\ngit reset 'HEAD@{1}'\n'''\n\n\n\nLong answer:\n\n\nGit keeps a log of all ref updates (e.g., checkout, reset, commit, merge). You can view it by typing:\n\n\n\n'''\ngit reflog\n'''\n\n\n\nSomewhere in this list is the commit that you lost. Let's say you just typed \ngit reset HEAD~\n and want to undo it. My reflog looks like this:\n\n\n\n'''\n$ git reflog\n3f6db14 HEAD@{0}: HEAD~: updating HEAD\nd27924e HEAD@{1}: checkout: moving from d27924e0fe16776f0d0f1ee2933a0334a4787b4c\n[...]\n'''\n\n\n\nThe first line says that \nHEAD\n 0 positions ago (in other words, the current position) is 3f6db14; it was obtained by resetting to \nHEAD~\n. The second line says that \nHEAD\n 1 position ago (in other words, the state before the reset) is d27924e. It was obtained by checking out a particular commit (though that's not important right now). So, to undo the reset, run \ngit reset HEAD@{1}\n (or \ngit reset d27924e\n).\n\n\nIf, on the other hand, you've run some other commands since then that update HEAD, the commit you want won't be at the top of the list, and you'll need to search through the \nreflog\n.\n\n\nOne final note: It may be easier to look at the \nreflog\n for the specific branch you want to un-reset, say master, rather than \nHEAD\n:\n\n\n\n'''\n$ git reflog show master\nc24138b master@{0}: merge origin/master: Fast-forward\n90a2bf9 master@{1}: merge origin/master: Fast-forward\n[...]\n'''\n\n\n\nThis should have less noise it in than the general \nHEAD reflog\n."
  },
  {
    "instruction": "Check existence of input argument in a Bash shell script",
    "response": "It is:\n\n\n\n'''\nif [ $# -eq 0 ]\n  then\n    echo \"No arguments supplied\"\nfi\n'''\n\n\n\nThe \n$#\n variable will tell you the number of input arguments the script was passed.\n\n\nOr you can check if an argument is an empty string or not like:\n\n\n\n'''\nif [ -z \"$1\" ]\n  then\n    echo \"No argument supplied\"\nfi\n'''\n\n\n\nThe \n-z\n switch will test if the expansion of \n\"$1\"\n is a null string or not. If it is a null string then the body is executed."
  },
  {
    "instruction": "How to undo \"git commit --amend\" done instead of \"git commit\"",
    "response": "What you need to do is to create a new commit with the same details as the current \nHEAD\n commit, but with the parent as the previous version of \nHEAD\n. \ngit reset --soft\n will move the branch pointer so that the next commit happens on top of a different commit from where the current branch head is now.\n\n\n\n'''\n# Move the current head so that it's pointing at the old commit\n# Leave the index intact for redoing the commit.\n# HEAD@{1} gives you \"the commit that HEAD pointed at before \n# it was moved to where it currently points at\". Note that this is\n# different from HEAD~1, which gives you \"the commit that is the\n# parent node of the commit that HEAD is currently pointing to.\"\ngit reset --soft HEAD@{1}\n\n# commit the current tree using the commit details of the previous\n# HEAD commit. (Note that HEAD@{1} is pointing somewhere different from the\n# previous command. It's now pointing at the erroneously amended commit.)\n# The -C option takes the given commit and reuses the log message and\n# authorship information.\ngit commit -C HEAD@{1}\n'''"
  },
  {
    "instruction": "Detach (move) subdirectory into separate Git repository",
    "response": "Update\n: This process is so common, that the git team made it much simpler with a new tool, \ngit subtree\n. See here: \nDetach (move) subdirectory into separate Git repository\n\n\n\n\nYou want to clone your repository and then use \ngit filter-branch\n to mark everything but the subdirectory you want in your new repo to be garbage-collected.\n\n\n\n\nTo clone your local repository:\n\n\n\n'''\ngit clone /XYZ /ABC\n'''\n\n\n\n(Note: the repository will be cloned using hard-links, but that is not a problem since the hard-linked files will not be modified in themselves - new ones will be created.)\n\n\nNow, let us preserve the interesting branches which we want to rewrite as well, and then remove the origin to avoid pushing there and to make sure that old commits will not be referenced by the origin:\n\n\n\n'''\ncd /ABC\nfor i in branch1 br2 br3; do git branch -t $i origin/$i; done\ngit remote rm origin\n'''\n\n\n\nor for all remote branches:\n\n\n\n'''\ncd /ABC\nfor i in $(git branch -r | sed \"s/.*origin\\///\"); do git branch -t $i origin/$i; done\ngit remote rm origin\n'''\n\n\n\nNow you might want to also remove tags which have no relation with the subproject; you can also do that later, but you might need to prune your repo again. I did not do so and got a \nWARNING: Ref 'refs/tags/v0.1' is unchanged\n for all tags (since they were all unrelated to the subproject); additionally, after removing such tags more space will be reclaimed. Apparently \ngit filter-branch\n should be able to rewrite other tags, but I could not verify this. If you want to remove all tags, use \ngit tag -l | xargs git tag -d\n.\n\n\nThen use filter-branch and reset to exclude the other files, so they can be pruned. Let's also add \n--tag-name-filter cat --prune-empty\n to remove empty commits and to rewrite tags (note that this will have to strip their signature):\n\n\n\n'''\ngit filter-branch --tag-name-filter cat --prune-empty --subdirectory-filter ABC -- --all\n'''\n\n\n\nor alternatively, to only rewrite the HEAD branch and ignore tags and other branches:\n\n\n\n'''\ngit filter-branch --tag-name-filter cat --prune-empty --subdirectory-filter ABC HEAD\n'''\n\n\n\nThen delete the backup reflogs so the space can be truly reclaimed (although now the operation is destructive)\n\n\n\n'''\ngit reset --hard\ngit for-each-ref --format=\"%(refname)\" refs/original/ | xargs -n 1 git update-ref -d\ngit reflog expire --expire=now --all\ngit gc --aggressive --prune=now\n'''\n\n\n\nand now you have a local git repository of the ABC sub-directory with all its history preserved. \n\n\n\n\nNote: For most uses, \ngit filter-branch\n should indeed have the added parameter \n-- --all\n. Yes that's really \n-\n-\nspace\n-\n-\n \nall\n.  This needs to be the last parameters for the command. As Matli discovered, this keeps the project branches and tags included in the new repo.\n\n\nEdit: various suggestions from comments below were incorporated to make sure, for instance, that the repository is actually shrunk (which was not always the case before)."
  },
  {
    "instruction": "How to find a deleted file in the project commit history?",
    "response": "If you do not know the exact path you may use\n\n\n\n'''\ngit log --all --full-history -- \"**/thefile.*\"\n'''\n\n\n\nIf you know the path the file was at, you can do this:\n\n\n\n'''\ngit log --all --full-history -- <path-to-file>\n'''\n\n\n\nThis should show a list of commits in all branches which touched that file. Then, you can find the version of the file you want, and display it with...\n\n\n\n'''\ngit show <SHA> -- <path-to-file>\n'''\n\n\n\nOr restore it into your working copy with:\n\n\ngit checkout <SHA>^ -- <path-to-file>\n\n\nNote the caret symbol (\n^\n), which gets the checkout \nprior\n to the one identified, because at the moment of \n<SHA>\n commit the file is deleted, we need to look at the previous commit to get the deleted file's contents"
  },
  {
    "instruction": "How to grep (search through) committed code in the Git history",
    "response": "You should use the \npickaxe (\n-S\n)\n option of \ngit log\n.\n\n\nTo search for \nFoo\n:\n\n\n\n'''\ngit log -SFoo -- path_containing_change\ngit log -SFoo --since=2009.1.1 --until=2010.1.1 -- path_containing_change\n'''\n\n\n\nSee \nGit history - find lost line by keyword\n for more.\n\n\n-S\n (named \npickaxe\n) comes originally from a \ngit diff\n option\n (Git v0.99, May 2005).\nThen \n-S\n (\npickaxe\n) was \nported to \ngit log\n in May 2006 with Git 1.4.0-rc1.\n\n\n\n\nAs \nJakub Narębski\n commented:\n\n\n\n\nthis \nlooks for differences that introduce or remove an instance of \n<string>\n.\nIt usually means \"revisions where you added or removed line with 'Foo'\".\n\n\n\n\nthe \n--pickaxe-regex\n option allows you to use extended POSIX regex instead of searching for a string.\nExample (from \ngit log\n): \ngit log -S\"frotz\\(nitfol\" --pickaxe-regex\n\n\n\n\n\n\n\n\nAs \nRob\n commented, this search is case-sensitive - he opened a \nfollow-up question\n on how to search case-insensitive.\n\n\n\n\nHi Angel\n notes in \nthe comments\n:\n\n\n\n\nExecuting a \ngit log -G<regexp> --branches --all\n (the \n-G\n is same as \n-S\n but for regexes) does same thing as the \naccepted one\n (\ngit grep <regexp> $(git rev-list --all)\n), but it soooo much faster!\n\n\nThe accepted answer was still searching for text after ≈10 minutes of me running it, whereas this one gives results after ≈4 seconds 🤷‍♂️.\nThe output here is more useful as well"
  },
  {
    "instruction": "How can I merge multiple commits onto another branch as a single squashed commit?",
    "response": "Say your bug fix branch is called \nbugfix\n and you want to merge it into \nmaster\n:\n\n\n\n'''\ngit checkout master\ngit merge --squash bugfix\ngit commit\n'''\n\n\n\nThis will take all the commits from the \nbugfix\n branch, squash them into 1 commit, and merge it with your \nmaster\n branch.\n\n\n\n\nExplanation\n:\n\n\n\n'''\ngit checkout master\n'''\n\n\n\nSwitches to your \nmaster\n branch.\n\n\n\n'''\ngit merge --squash bugfix\n'''\n\n\n\nTakes all commits from the \nbugfix\n branch and groups it for a 1 commit with your current branch.\n\n\n(no merge commit appears; you could resolve conflicts manually before following commit)\n\n\n\n'''\ngit commit\n'''\n\n\n\nCreates a single commit from the merged changes.\n\n\nOmitting the \n-m\n parameter lets you modify a draft commit message containing every message from your squashed commits before finalizing your commit."
  },
  {
    "instruction": "How to \"git diff\" the working tree to the stash?",
    "response": "See the most recent stash:\n\n\n\n'''\ngit stash show -p\n'''\n\n\n\nSee an arbitrary stash:\n\n\n\n'''\ngit stash show -p stash@{1}\n'''\n\n\n\nFrom the \ngit stash\n manpages:\n\n\n\n\nBy default, the command shows the diffstat, but it will accept any\n  format known to git diff (e.g., git stash show -p stash@{1} to view\n  the second most recent stash in patch form)."
  },
  {
    "instruction": "Git push requires username and password",
    "response": "A common cause is cloning using the default (HTTPS) instead of SSH. You can correct this by going to your repository, clicking \"Clone or download\", then clicking the \"Use SSH\" button above the URL field and updating the URL of your origin remote like this:\n\n\n\n'''\ngit remote set-url origin git@github.com:username/repo.git\n'''\n\n\n\nYou can check if you have added the remote as HTTPS or SSH using:\n\n\n\n'''\ngit remote -v\n'''\n\n\n\nThis is documented at GitHub: \nSwitching remote URLs from HTTPS to SSH\n."
  },
  {
    "instruction": "How do I properly force a Git push?",
    "response": "Just do:\n\n\n\n'''\ngit push origin <your_branch_name> --force\n'''\n\n\n\nor if you have a specific repo:\n\n\n\n'''\ngit push https://git.... --force\n'''\n\n\n\nThis will delete your previous commit(s) and push your current one.\n\n\nIt may not be proper, but if anyone stumbles upon this page, thought they might want a simple solution...\n\n\nShort flag\n\n\nAlso note that \n-f\n is short for \n--force\n, so\n\n\n\n'''\ngit push origin <your_branch_name> -f\n'''\n\n\n\nwill also work."
  },
  {
    "instruction": "How do I prompt for Yes/No/Cancel input in a Linux shell script?",
    "response": "A widely available method to get user input at a shell prompt is the \nread\n command. Here is a demonstration:\n\n\n\n'''\nwhile true; do\n    read -p \"Do you wish to install this program? \" yn\n    case $yn in\n        [Yy]* ) make install; break;;\n        [Nn]* ) exit;;\n        * ) echo \"Please answer yes or no.\";;\n    esac\ndone\n'''\n\n\n\n\n\nAnother method, \npointed out\n by \nSteven Huwig\n, is Bash's \nselect\n command. Here is the same example using \nselect\n:\n\n\n\n'''\necho \"Do you wish to install this program?\"\nselect yn in \"Yes\" \"No\"; do\n    case $yn in\n        Yes ) make install; break;;\n        No ) exit;;\n    esac\ndone\n'''\n\n\n\nWith \nselect\n you don't need to sanitize the input – it displays the available choices, and you type a number corresponding to your choice. It also loops automatically, so there's no need for a \nwhile true\n loop to retry if they give invalid input. If you want to allow more flexible input (accepting the words of the options, rather than \njust their number\n), you can alter it like this:\n\n\n\n'''\necho \"Do you wish to install this program?\"\nselect strictreply in \"Yes\" \"No\"; do\n    relaxedreply=${strictreply:-$REPLY}\n    case $relaxedreply in\n        Yes | yes | y ) make install; break;;\n        No  | no  | n ) exit;;\n    esac\ndone\n'''\n\n\n\n\n\nAlso, \nLéa Gris\n demonstrated a way to make the request language agnostic in \nher answer\n. Adapting my first example to better serve multiple languages might look like this:\n\n\n\n'''\nset -- $(locale LC_MESSAGES)\nyesexpr=\"$1\"; noexpr=\"$2\"; yesword=\"$3\"; noword=\"$4\"\n\nwhile true; do\n    read -p \"Install (${yesword} / ${noword})? \" yn\n    if [[ \"$yn\" =~ $yesexpr ]]; then make install; exit; fi\n    if [[ \"$yn\" =~ $noexpr ]]; then exit; fi\n    echo \"Answer ${yesword} / ${noword}.\"\ndone\n'''\n\n\n\nObviously other communication strings remain untranslated here (Install, Answer) which would need to be addressed in a more fully completed translation, but even a partial translation would be helpful in many cases.\n\n\n\n\nFinally, please check out the \nexcellent answer\n by \nF. Hauri\n."
  },
  {
    "instruction": "How do I configure git to ignore some files locally?",
    "response": "From \nthe relevant Git documentation\n:\n\n\n\n\nPatterns which are specific to a particular repository but which do not need to be shared with other related repositories (e.g., auxiliary files that live inside the repository but are specific to one user's workflow) should go into the \n$GIT_DIR/info/exclude\n file.\n\n\n\n\nThe \n.git/info/exclude\n file has the same format as any \n.gitignore\n file. Another option is to set \ncore.excludesFile\n to the name of a file containing global patterns.\n\n\nNote, if you already have unstaged changes you must run the following after editing your ignore-patterns:\n\n\n\n'''\ngit update-index --assume-unchanged <file-list>\n'''\n\n\n\nNote on \n$GIT_DIR\n: This is a notation used \nall over\n the git manual simply to indicate the path to the git repository. If the environment variable is set, then it will override the location of whichever repo you're in, which probably isn't what you want.\n\n\n\n\nEdit\n: Another way is to use:\n\n\n\n'''\ngit update-index --skip-worktree <file-list>\n'''\n\n\n\nReverse it by:\n\n\n\n'''\ngit update-index --no-skip-worktree <file-list>\n'''"
  },
  {
    "instruction": "git: how to rename a branch (both local and remote)?",
    "response": "There are a few ways to accomplish that:\n\n\n\n\nChange your local branch and then push your changes\n\n\nPush the branch to remote with the new name while keeping the original name locally\n\n\n\n\nRenaming local and remote\n\n\n\n'''\n# Names of things - allows you to copy/paste commands\nold_name=feature/old\nnew_name=feature/new\nremote=origin\n\n# Rename the local branch to the new name\ngit branch -m $old_name $new_name\n\n# Delete the old branch on remote\ngit push $remote --delete $old_name\n\n# Or shorter way to delete remote branch [:]\ngit push $remote :$old_name\n\n# Prevent git from using the old name when pushing in the next step.\n# Otherwise, git will use the old upstream name instead of $new_name.\ngit branch --unset-upstream $new_name\n\n# Push the new branch to remote\ngit push $remote $new_name\n\n# Reset the upstream branch for the new_name local branch\ngit push $remote -u $new_name\n'''\n\n\n\n\n\n\n\nRenaming Only remote branch\n\n\nCredit: \nptim\n\n\n\n'''\n# In this option, we will push the branch to the remote with the new name\n# While keeping the local name as is\ngit push $remote $remote/$old_name:refs/heads/$new_name :$old_name\n'''\n\n\n\n\n\nImportant note:\n\n\nWhen you use the \ngit branch -m\n (move), Git is also \nupdating\n your tracking branch with the new name.\n\n\n\n\ngit remote rename legacy legacy\n\n\n\n\ngit remote rename\n is trying to update your remote section in your configuration file. It will rename the remote with the given name to the new name, but in your case, it did not find any, so the renaming failed.\n\n\nBut\n it will not do what you think; it will rename your \nlocal\n configuration remote name and \nnot\n the remote branch. \n\n\n\n\nNote\n\nGit servers might allow you to rename Git branches using the web interface or external programs (like Sourcetree, etc.), but you have to keep in mind that in Git all the work is done locally, so it's recommended to use the above commands to the work."
  },
  {
    "instruction": "Break a previous commit into multiple commits",
    "response": "git rebase -i\n will do it.\n\n\nFirst, start with a clean working directory: \ngit status\n should show no pending modifications, deletions, or additions.\n\n\nNow, you have to decide which commit(s) you want to split.\n\n\nA) Splitting the most recent commit\n\n\nTo split apart your most recent commit, first:\n\n\n\n'''\n$ git reset HEAD~\n'''\n\n\n\nNow commit the pieces individually in the usual way, producing as many commits as you need.\n\n\nB) Splitting a commit farther back\n\n\nThis requires \nrebasing\n, that is, rewriting history. To specify the correct commit, you have several choices:\n\n\n\n\nIf it is three commits back, then\n\n\n\n'''\n$ git rebase -i HEAD~3\n'''\n\n\n\nwhere \n3\n is how many commits back it is.\n\n\n\n\nIf it is farther back in the tree than you want to count, then\n\n\n\n'''\n$ git rebase -i 123abcd~\n'''\n\n\n\nwhere \n123abcd\n is the SHA1 of the commit you want to split up.\n\n\n\n\nIf you want to rebase the entire current branch simply do:\n\n\n\n'''\n$ git rebase -i\n'''\n\n\n\n\n\nIf you are on a different branch (e.g., a feature branch) that you want to merge into \nmaster\n:\n\n\n\n'''\n$ git rebase -i master\n'''\n\n\n\n\n\n\n\nWhen you get the rebase edit screen, find the commit you want to break apart.  At the beginning of that line, replace \npick\n with \nedit\n (\ne\n for short).  Save the buffer and exit.  Rebase will now stop just after the commit you want to edit.  Then:\n\n\n\n'''\n$ git reset HEAD~\n'''\n\n\n\nCommit the pieces individually in the usual way, producing as many commits as you need.\n\n\nFinally\n\n\n\n'''\n$ git rebase --continue\n'''\n\n\n\nIf you want to preserve authorship\n\n\nIf you want to preserve the authorship of commits, and possibly the date as well, see \ncopy author and date from other commit, but _not_ the message"
  },
  {
    "instruction": "How to specify the private SSH-key to use when executing shell command on Git?",
    "response": "Something like this should work (suggested by orip):\n\n\n\n'''\nssh-agent bash -c 'ssh-add /somewhere/yourkey; git clone git@github.com:user/project.git'\n'''\n\n\n\nif you prefer subshells, you could try the following (though it is more fragile):\n\n\n\n'''\nssh-agent $(ssh-add /somewhere/yourkey; git clone git@github.com:user/project.git)\n'''\n\n\n\nGit will invoke SSH which will find its agent by environment variable; this will, in turn, have the key loaded.\n\n\nAlternatively, setting \nHOME\n may also do the trick, provided you are willing to setup a directory that contains only a \n.ssh\n directory as \nHOME\n; this may either contain an identity.pub, or a \nconfig file\n setting IdentityFile."
  },
  {
    "instruction": "Make a Bash alias that takes a parameter?",
    "response": "Bash alias does not directly accept parameters. You will have to create a function.\n\n\nalias\n does not accept parameters but a function can be called just like an alias. For example:\n\n\n\n'''\nmyfunction() {\n    #do things with parameters like $1 such as\n    mv \"$1\" \"$1.bak\"\n    cp \"$2\" \"$1\"\n}\n\n\nmyfunction old.conf new.conf #calls `myfunction`\n'''\n\n\n\nBy the way, Bash functions defined in your \n.bashrc\n and other files are available as commands within your shell. So for instance you can call the earlier function like this \n\n\n\n'''\n$ myfunction original.conf my.conf\n'''"
  },
  {
    "instruction": "Hard reset of a single file",
    "response": "To reset both the working copy of \nmy-file.txt\n and its state in the Git index to that of HEAD:\n\n\n\n'''\ngit checkout HEAD -- my-file.txt\n'''\n\n\n\n--\n means \n\"treat every argument after this point as a filename\"\n. More details in \nthis answer\n. Thanks to \nVonC\n for pointing this out."
  },
  {
    "instruction": "How to convert a string to lower case in Bash",
    "response": "There are various ways:\n\n\nPOSIX standard\n\n\ntr\n\n\n\n'''\n$ echo \"$a\" | tr '[:upper:]' '[:lower:]'\nhi all\n'''\n\n\n\nAWK\n\n\n\n'''\n$ echo \"$a\" | awk '{print tolower($0)}'\nhi all\n'''\n\n\n\nNon-POSIX\n\n\nYou may run into portability issues with the following examples:\n\n\nBash 4.0\n\n\n\n'''\n$ echo \"${a,,}\"\nhi all\n'''\n\n\n\nsed\n\n\n\n'''\n$ echo \"$a\" | sed -e 's/\\(.*\\)/\\L\\1/'\nhi all\n# this also works:\n$ sed -e 's/\\(.*\\)/\\L\\1/' <<< \"$a\"\nhi all\n'''\n\n\n\nPerl\n\n\n\n'''\n$ echo \"$a\" | perl -ne 'print lc'\nhi all\n'''\n\n\n\nBash\n\n\n\n'''\nlc(){\n    case \"$1\" in\n        [A-Z])\n        n=$(printf \"%d\" \"'$1\")\n        n=$((n+32))\n        printf \\\\$(printf \"%o\" \"$n\")\n        ;;\n        *)\n        printf \"%s\" \"$1\"\n        ;;\n    esac\n}\nword=\"I Love Bash\"\nfor((i=0;i<${#word};i++))\ndo\n    ch=\"${word:$i:1}\"\n    lc \"$ch\"\ndone\n'''\n\n\n\nNote: YMMV on this one. Doesn't work for me (GNU bash version 4.2.46 and 4.0.33 (and same behaviour 2.05b.0 but \nnocasematch\n  is not implemented)) even with using \nshopt -u nocasematch;\n. Unsetting that \nnocasematch\n causes \n[[ \"fooBaR\" == \"FOObar\" ]]\n to match OK BUT inside case weirdly \n[b-z]\n are incorrectly matched by \n[A-Z]\n. Bash is confused by the double-negative (\"unsetting nocasematch\")! :-)"
  },
  {
    "instruction": "How do I revert a merge commit that has already been pushed to remote?",
    "response": "In \ngit revert -m\n, the \n-m\n option specifies the \nparent number\n. This is needed because a merge commit has more than one parent, and Git does not know automatically which parent was the mainline, and which parent was the branch you want to un-merge.\n\n\nWhen you view a merge commit in the output of \ngit log\n, you will see its parents listed on the line that begins with \nMerge:\n (the second line in this case):\n\n\n\n'''\ncommit 8f937c683929b08379097828c8a04350b9b8e183\nMerge: 8989ee0 7c6b236\nAuthor: Ben James <ben@example.com>\nDate:   Wed Aug 17 22:49:41 2011 +0100\n\nMerge branch 'gh-pages'\n\nConflicts:\n    README\n'''\n\n\n\nIn this situation, \ngit revert 8f937c6 -m 1\n will get you the tree as it was in \n8989ee0\n, and \ngit revert -m 2\n will reinstate the tree as it was in \n7c6b236\n.\n\n\nTo better understand what you're about to revert do \ngit diff <parent_commit> <commit_to_revert>\n, in this case:\n\n\n\n'''\ngit diff 8989ee0 8f937c6\n'''\n\n\n\nand\n\n\n\n'''\ngit diff 7c6b236 8f937c6\n'''\n\n\n\nHowever, it's \nvery important\n you realize that in doing so\n\n\n\n\n\"...declares that you will never want the tree changes brought in by the merge. As a result, later merges will only bring in tree changes introduced by commits that are not ancestors of the previously reverted merge. This may or may not be what you want. See the \nrevert-a-faulty-merge How-To\n for more details.\" (\ngit-merge man page\n)."
  },
  {
    "instruction": "LF will be replaced by CRLF in git - What is that and is it important?",
    "response": "In Unix systems the end of a line is represented with a line feed (LF). In windows a line is represented with a carriage return (CR) and a line feed (LF) thus (CRLF). when you get code from git that was uploaded from a unix system they will only have an LF.\n\n\nIf you are a single developer working on a windows machine, and you don't care that git automatically replaces LFs to CRLFs, you can turn this warning off by typing the following in the git command line\n\n\n\n'''\ngit config core.autocrlf true\n'''\n\n\n\nIf you want to make an intelligent decision how git should handle this, \nread the documentation\n \n\n\nHere is a snippet\n\n\n\n\nFormatting and Whitespace\n\n\nFormatting and whitespace issues are some of the more frustrating and\n  subtle problems that many developers encounter when collaborating,\n  especially cross-platform. It’s very easy for patches or other\n  collaborated work to introduce subtle whitespace changes because\n  editors silently introduce them, and if your files ever touch a\n  Windows system, their line endings might be replaced. Git has a few\n  configuration options to help with these issues.\n\n\n\n'''\ncore.autocrlf\n'''\n\n\n\nIf you’re programming on Windows and working with people who are not\n  (or vice-versa), you’ll probably run into line-ending issues at some\n  point. This is because Windows uses both a carriage-return character\n  and a linefeed character for newlines in its files, whereas Mac and\n  Linux systems use only the linefeed character. This is a subtle but\n  incredibly annoying fact of cross-platform work; many editors on\n  Windows silently replace existing LF-style line endings with CRLF, or\n  insert both line-ending characters when the user hits the enter key.\n\n\nGit can handle this by auto-converting CRLF line endings into LF when\n  you add a file to the index, and vice versa when it checks out code\n  onto your filesystem. You can turn on this functionality with the\n  core.autocrlf setting. If you’re on a Windows machine, set it to true\n  – this converts LF endings into CRLF when you check out code:\n\n\n\n'''\n$ git config --global core.autocrlf true\n'''\n\n\n\nIf you’re on a Linux or Mac system that uses LF line endings, then you\n  don’t want Git to automatically convert them when you check out files;\n  however, if a file with CRLF endings accidentally gets introduced,\n  then you may want Git to fix it. You can tell Git to convert CRLF to\n  LF on commit but not the other way around by setting core.autocrlf to\n  input:\n\n\n\n'''\n$ git config --global core.autocrlf input\n'''\n\n\n\nThis setup should leave you with CRLF endings in Windows checkouts,\n  but LF endings on Mac and Linux systems and in the repository.\n\n\nIf you’re a Windows programmer doing a Windows-only project, then you\n  can turn off this functionality, recording the carriage returns in the\n  repository by setting the config value to false:\n\n\n\n'''\n$ git config --global core.autocrlf false\n'''"
  },
  {
    "instruction": "How can I selectively merge or pick changes from another branch in Git?",
    "response": "You use the \ncherry-pick\n command to get individual commits from one branch.\n\n\nIf the change(s) you want are not in individual commits, then use the method shown here to \nsplit the commit into individual commits\n. Roughly speaking, you use \ngit rebase -i\n to get the original commit to edit, then \ngit reset HEAD^\n to selectively revert changes, then \ngit commit\n to commit that bit as a new commit in the history.\n\n\nThere is another nice method here\n in Red Hat Magazine, where they use \ngit add --patch\n or possibly \ngit add --interactive\n which allows you to add just parts of a hunk, if you want to split different changes to an individual file (search in that page for \"split\").\n\n\nHaving split the changes, you can now cherry-pick just the ones you want."
  },
  {
    "instruction": "How can I Remove .DS_Store files from a Git repository?",
    "response": "Remove existing \n.DS_Store\n files from the repository:\n\n\n\n'''\nfind . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch\n'''\n\n\n\nAdd this line:\n\n\n\n'''\n.DS_Store\n'''\n\n\n\nto the file \n.gitignore\n, which can be found at the top level of your repository (or create the file if it isn't there already). You can do this easily with this command in the top directory:\n\n\n\n'''\necho .DS_Store >> .gitignore\n'''\n\n\n\nThen commit the file to the repo:\n\n\n\n'''\ngit add .gitignore\ngit commit -m '.DS_Store banished!'\n'''"
  },
  {
    "instruction": "How do I show my global Git configuration?",
    "response": "You can use:\n\n\n\n'''\ngit config --list\n'''\n\n\n\nor look at your \n~/.gitconfig\n file. The local configuration will be in your repository's \n.git/config\n file.\n\n\nUse:\n\n\n\n'''\ngit config --list --show-origin\n'''\n\n\n\nto see where that setting is defined (global, user, repo, etc...)"
  },
  {
    "instruction": "You have not concluded your merge (MERGE_HEAD exists)",
    "response": "The problem is your previous pull failed to merge automatically and went to conflict state. And the conflict wasn't resolved properly before the next pull.\n\n\n\n\nUndo the merge and pull again.\n\n\nTo undo a merge:\n\n\ngit merge --abort\n  [Since git version 1.7.4]\n\n\ngit reset --merge\n  [prior git versions]\n\n\n\n\nResolve the conflict.\n\n\n\n\nDon't forget to add and commit the merge.\n\n\n\n\ngit pull\n now should work fine."
  },
  {
    "instruction": ".gitignore is ignored by Git",
    "response": "Fixed. OK, I created the .gitignore file in Notepad on Windows and it wasn't working. When I viewed the .gitignore file on Linux it looked like organised gibberish - perhaps Notepad had written out Unicode rather than ASCII or whatever 8-bit is.\n\n\nSo I rewrote the file on my Linux box, and when I pulled it back into Windows it works fine! Hurrah!"
  },
  {
    "instruction": "How can I reconcile detached HEAD with master/origin?",
    "response": "First, let’s clarify \nwhat HEAD is\n and what it means when it is detached.  \n\n\nHEAD is the symbolic name for the currently checked out commit. When HEAD is not detached (the “normal”\n1\n situation: you have a branch checked out), HEAD actually points to a branch’s “ref” and the branch points to the commit. HEAD is thus “attached” to a branch. When you make a new commit, the branch that HEAD points to is updated to point to the new commit. HEAD follows automatically since it just points to the branch.\n\n\n\n\ngit symbolic-ref HEAD\n yields \nrefs/heads/master\n\nThe branch named “master” is checked out.\n\n\ngit rev-parse refs/heads/master\n yield \n17a02998078923f2d62811326d130de991d1a95a\n\nThat commit is the current tip or “head” of the master branch.\n\n\ngit rev-parse HEAD\n also yields \n17a02998078923f2d62811326d130de991d1a95a\n\nThis is what it means to be a “symbolic ref”. It points to an object through some other reference.\n\n(Symbolic refs were originally implemented as symbolic links, but later changed to plain files with extra interpretation so that they could be used on platforms that do not have symlinks.)\n\n\n\n\nWe have \nHEAD\n → \nrefs/heads/master\n → \n17a02998078923f2d62811326d130de991d1a95a\n\n\nWhen HEAD is detached, it points directly to a commit—instead of indirectly pointing to one through a branch. You can think of a detached HEAD as being on an unnamed branch. \n\n\n\n\ngit symbolic-ref HEAD\n fails with \nfatal: ref HEAD is not a symbolic ref\n\n\ngit rev-parse HEAD\n yields \n17a02998078923f2d62811326d130de991d1a95a\n\nSince it is not a symbolic ref, it must point directly to the commit itself.\n\n\n\n\nWe have \nHEAD\n → \n17a02998078923f2d62811326d130de991d1a95a\n\n\nThe important thing to remember with a detached HEAD is that if the commit it points to is otherwise unreferenced (no other ref can reach it), then it will become “dangling” when you checkout some other commit. Eventually, such dangling commits will be pruned through the garbage collection process (by default, they are kept for at least 2 weeks and may be kept longer by being referenced by HEAD’s reflog).\n\n\n1\n\nIt is perfectly fine to do “normal” work with a detached HEAD, you just have to keep track of what you are doing to avoid having to fish dropped history out of the reflog.\n\n\n\n\nThe intermediate steps of an interactive rebase are done with a detached HEAD (partially to avoid polluting the active branch’s reflog). If you finish the full rebase operation, it will update your original branch with the cumulative result of the rebase operation and reattach HEAD to the original branch. My guess is that you never fully completed the rebase process; this will leave you with a detached HEAD pointing to the commit that was most recently processed by the rebase operation.\n\n\nTo recover from your situation, you should create a branch that points to the commit currently pointed to by your detached HEAD:\n\n\n\n'''\ngit branch temp\ngit checkout temp\n'''\n\n\n\n(these two commands can be abbreviated as \ngit checkout -b temp\n)\n\n\nThis will reattach your HEAD to the new \ntemp\n branch.\n\n\nNext, you should compare the current commit (and its history) with the normal branch on which you expected to be working:\n\n\n\n'''\ngit log --graph --decorate --pretty=oneline --abbrev-commit master origin/master temp\ngit diff master temp\ngit diff origin/master temp\n'''\n\n\n\n(You will probably want to experiment with the log options: add \n-p\n, leave off \n--pretty=…\n to see the whole log message, etc.)\n\n\nIf your new \ntemp\n branch looks good, you may want to update (e.g.) \nmaster\n to point to it:\n\n\n\n'''\ngit branch -f master temp\ngit checkout master\n'''\n\n\n\n(these two commands can be abbreviated as \ngit checkout -B master temp\n)\n\n\nYou can then delete the temporary branch:\n\n\n\n'''\ngit branch -d temp\n'''\n\n\n\nFinally, you will probably want to push the reestablished history:\n\n\n\n'''\ngit push origin master\n'''\n\n\n\nYou may need to add \n--force\n to the end of this command to push if the remote branch can not be “fast-forwarded” to the new commit (i.e. you dropped, or rewrote some existing commit, or otherwise rewrote some bit of history).\n\n\nIf you were in the middle of a rebase operation you should probably clean it up. You can check whether a rebase was in process by looking for the directory \n.git/rebase-merge/\n. You can manually clean up the in-progress rebase by just deleting that directory (e.g. if you no longer remember the purpose and context of the active rebase operation). Usually you would use \ngit rebase --abort\n, but that does some extra resetting that you probably want to avoid (it moves HEAD back to the original branch and resets it back to the original commit, which will undo some of the work we did above)."
  },
  {
    "instruction": "How can I revert multiple Git commits?",
    "response": "Expanding what I wrote in a comment\n\n\nThe general rule is that you should not rewrite (change) history that you have published, because somebody might have based their work on it.  If you rewrite (change) history, you would make problems with merging their changes and with updating for them.\n\n\nSo the solution is to create a \nnew commit\n which \nreverts changes\n that you want to get rid of.  You can do this using \ngit revert\n command.\n\n\nYou have the following situation:\n\n\n\n'''\nA <-- B  <-- C <-- D                                  <-- master <-- HEAD\n'''\n\n\n\n(arrows here refers to the direction of the pointer: the \"parent\" reference in the case of commits, the top commit in the case of branch head (branch ref), and the name of branch in the case of HEAD reference).\n\n\nWhat you need to create is the following:\n\n\n\n'''\nA <-- B  <-- C <-- D <-- [(BCD)-1]                   <-- master <-- HEAD\n'''\n\n\n\nwhere \n[(BCD)^-1]\n means the commit that reverts changes in commits B, C, D.  Mathematics tells us that (BCD)\n-1\n = D\n-1\n C\n-1\n B\n-1\n, so you can get the required situation using the following commands:\n\n\n\n'''\n$ git revert --no-commit D\n$ git revert --no-commit C\n$ git revert --no-commit B\n$ git commit -m \"the commit message for all of them\"\n'''\n\n\n\nWorks for everything except merge commits.\n\n\n\n\nAlternate solution would be to \ncheckout\n \ncontents\n of commit A, and commit this state.  Also works with merge commits.  Added files will not be deleted, however.  If you have any local changes \ngit stash\n them first:\n\n\n\n'''\n$ git checkout -f A -- . # checkout that revision over the top of local files\n$ git commit -a\n'''\n\n\n\nThen you would have the following situation:\n\n\n\n'''\nA <-- B  <-- C <-- D <-- A'                       <-- master <-- HEAD\n'''\n\n\n\nThe commit A' has the same contents as commit A, but is a different commit (commit message, parents, commit date).\n\n\n\n\nAlternate \nsolution by Jeff Ferland, modified by Charles Bailey\n builds upon the same idea, but uses \ngit reset\n.  Here it is slightly modified, this way WORKS FOR EVERYTHING:\n\n\n\n'''\n$ git reset --hard A\n$ git reset --soft D # (or ORIG_HEAD or @{1} [previous location of HEAD]), all of which are D\n$ git commit\n'''"
  },
  {
    "instruction": "Create a branch in Git from another branch",
    "response": "If you like the method in the link you've posted, have a look at \nGit Flow\n.\n\n\nIt's a set of scripts he created for that workflow.\n\n\nBut to answer your question:\n\n\n\n'''\ngit checkout -b myFeature dev\n'''\n\n\n\nCreates the \nmyFeature\n branch off \ndev\n. Do your work and then\n\n\n\n'''\ngit commit -am \"Your message\"\n'''\n\n\n\nNow merge your changes to \ndev\n without a fast-forward\n\n\n\n'''\ngit checkout dev\ngit merge --no-ff myFeature\n'''\n\n\n\nNow push the changes to the server\n\n\n\n'''\ngit push origin dev\ngit push origin myFeature\n'''\n\n\n\nAnd you'll see it how you want it."
  },
  {
    "instruction": "Changing git commit message after push (given that no one pulled from remote)",
    "response": "Changing history\n\n\nIf it is the most recent commit, you can simply do this:\n\n\n\n'''\ngit commit --amend\n'''\n\n\n\nThis brings up the editor with the last commit message and lets you edit the message.  (You can use \n-m\n if you want to wipe out the old message and use a new one.)\n\n\nPushing\n\n\nAnd then when you push, do this:\n\n\n\n'''\ngit push --force-with-lease <repository> <branch>\n'''\n\n\n\nOr you can use \"+\":\n\n\n\n'''\ngit push <repository> +<branch>\n'''\n\n\n\nOr you can use \n--force\n:\n\n\n\n'''\ngit push --force <repository> <branch>\n'''\n\n\n\nBe careful when using these commands.\n\n\n\n\nIf someone else pushed changes to the same branch, you probably want to avoid destroying those changes.  The \n--force-with-lease\n option is the safest, because it will abort if there are any upstream changes (\n\n\nIf you don't specify the branch explicitly, Git will use the default push settings.  If your default push setting is \"matching\", then you may destroy changes on several branches at the same time. \n\n\n\n\nPulling / fetching afterwards\n\n\nAnyone who already pulled will now get an error message, and they will need to update (assuming they aren't making any changes themselves) by doing something like this:\n\n\n\n'''\ngit fetch origin\ngit reset --hard origin/master # Loses local commits\n'''\n\n\n\nBe careful when using \nreset --hard\n.  If you have changes to the branch, those changes will be destroyed.\n\n\nA note about modifying history\n\n\nThe destroyed data is really just the old commit message, but \n--force\n doesn't know that, and will happily delete other data too.  So think of \n--force\n as \"I want to destroy data, and I know for sure what data is being destroyed.\"  But when the destroyed data is committed, you can often recover old commits from the reflog—the data is actually \norphaned\n instead of destroyed (although orphaned commits are periodically deleted).\n\n\nIf you don't think you're destroying data, then stay away from \n--force\n... \nbad things might happen\n.\n\n\nThis is why \n--force-with-lease\n is somewhat safer."
  },
  {
    "instruction": "How do I remove a directory from a Git repository?",
    "response": "Remove directory from Git and local\n\n\nCheckout 'master' with both directories:\n\n\n\n'''\ngit rm -r one-of-the-directories // This deletes from filesystem\ngit commit . -m \"Remove duplicated directory\"\ngit push origin <your-git-branch> (typically 'master', but not always)\n'''\n\n\n\nRemove directory from Git but NOT local\n\n\nTo remove this directory from Git, but not delete it entirely from the filesystem (local):\n\n\n\n'''\ngit rm -r --cached myFolder\n'''"
  },
  {
    "instruction": "How can I view a git log of just one user's commits?",
    "response": "This works for both \ngit log\n and \ngitk\n - the 2 most common ways of viewing history.\n\nYou don't need to use the whole name:\n\n\n\n'''\ngit log --author=\"Jon\"\n'''\n\n\n\nwill match a commit made by \"Jonathan Smith\"\n\n\n\n'''\ngit log --author=Jon\n'''\n\n\n\nand\n\n\n\n'''\ngit log --author=Smith\n'''\n\n\n\nwould also work. The quotes are optional if you don't need any spaces.\n\n\nAdd \n--all\n if you intend to search all branches and not just the current commit's ancestors in your repo.\n\n\nYou can also easily match on multiple authors as regex is the underlying mechanism for this filter. So to list commits by Jonathan or Adam, you can do this:\n\n\n\n'''\ngit log --author=\"\\(Adam\\)\\|\\(Jon\\)\"\n'''\n\n\n\nIn order to exclude commits by a particular author or set of authors using regular expressions as noted \nin this question\n, you can use a \nnegative lookahead\n in combination with the \n--perl-regexp\n switch:\n\n\n\n'''\ngit log --author='^(?!Adam|Jon).*$' --perl-regexp\n'''\n\n\n\nAlternatively, you can exclude commits authored by Adam by using \nbash\n and piping:\n\n\n\n'''\ngit log --format='%H %an' | \n  grep -v Adam | \n  cut -d ' ' -f1 | \n  xargs -n1 git log -1\n'''\n\n\n\nIf you want to exclude commits commited (but not necessarily authored) by Adam, replace \n%an\n with \n%cn\n. More details about this are in my blog post here: \nhttp://dymitruk.com/blog/2012/07/18/filtering-by-author-name/"
  },
  {
    "instruction": "How can I undo git reset --hard HEAD~1?",
    "response": "Pat Notz is correct.  You can get the commit back so long as it's been within a few days.  git only garbage collects after about a month or so unless you explicitly tell it to remove newer blobs.\n\n\n\n'''\n$ git init\nInitialized empty Git repository in .git/\n\n$ echo \"testing reset\" > file1\n$ git add file1\n$ git commit -m 'added file1'\nCreated initial commit 1a75c1d: added file1\n 1 files changed, 1 insertions(+), 0 deletions(-)\n create mode 100644 file1\n\n$ echo \"added new file\" > file2\n$ git add file2\n$ git commit -m 'added file2'\nCreated commit f6e5064: added file2\n 1 files changed, 1 insertions(+), 0 deletions(-)\n create mode 100644 file2\n\n$ git reset --hard HEAD^\nHEAD is now at 1a75c1d... added file1\n\n$ cat file2\ncat: file2: No such file or directory\n\n$ git reflog\n1a75c1d... HEAD@{0}: reset --hard HEAD^: updating HEAD\nf6e5064... HEAD@{1}: commit: added file2\n\n$ git reset --hard f6e5064\nHEAD is now at f6e5064... added file2\n\n$ cat file2\nadded new file\n'''\n\n\n\nYou can see in the example that the file2 was removed as a result of the hard reset, but was put back in place when I reset via the reflog."
  }
]